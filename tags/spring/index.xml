<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>spring on kyon's wonderland with ❤️</title><link>https://kyon.life/tags/spring/</link><description>Recent content in spring on kyon's wonderland with ❤️</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 17 Jan 2021 15:10:12 +0800</lastBuildDate><atom:link href="https://kyon.life/tags/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 spring cloud openfeign 的一些小技巧</title><link>https://kyon.life/post/tricks-with-feign/</link><pubDate>Sun, 17 Jan 2021 15:10:12 +0800</pubDate><guid>https://kyon.life/post/tricks-with-feign/</guid><description>spring cloud openfeign（以下简称 feign） 通过一个额外定义的 interface 文件作为接口定义，可以将对外提供的 HTTP 接口转换为 API 接口，提供方和调用方需要共同依赖接口文件，将隐式的依赖关系显性表示出来。而且在这个接口文件上也可以大作文章，比如配置服务发现、接口拦截操作等。
一个最简单的 feign 接口文件 DemoClient.java：
1 2 3 4 5 6 7 8 package com.example.demo; @FeignClient(name=&amp;#34;demo&amp;#34;, url=&amp;#34;http://127.0.0.1:8081/&amp;#34;) public interface DemoClient { @GetMapping(&amp;#34;/hello&amp;#34;) String hello(@RequestParam String name); } name 为全局唯一，是这个 FeignClient 的唯一标识，url 为提供方的接口地址。理论上 FeignClient 文件由接口提供方作为合约文件给到调用方，但是即使提供方未提供，只要提供方暴露了 HTTP 接口，那么调用方就可以通过定义 FeignClient 文件将 HTTP 接口调用转换为 API 调用。
调用方使用 DemoClient 示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.</description></item><item><title>Spring 框架缓存故障自动切换</title><link>https://kyon.life/post/dynamic-switch-cache-in-spring/</link><pubDate>Tue, 29 Sep 2020 15:40:36 +0800</pubDate><guid>https://kyon.life/post/dynamic-switch-cache-in-spring/</guid><description>现状 缓存只是提高访问速度，应用本身没有很高的并发访问量，缓存不可用时，数据库也能顶住。但是缓存挂掉以后，Spring CacheManager 默认会抛出异常，方法直接就异常退出了。
目标 缓存不可用时，不影响应用正常运行，不影响接口正常返回。
解决方案 方案一 最直接的方案，Spring 定义的 error handler 默认是抛出异常，覆盖 handler 并 catch 住异常不要抛出就可以不影响正常处理流程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class CacheErrorLoggingHandler extends SimpleCacheErrorHandler { private Logger logger = LoggerFactory.getLogger(CacheErrorLoggingHandler.class); private ClientResources clientResources; public void setClientResources(ClientResources clientResources) { this.clientResources = clientResources; } @Override public void handleCacheGetError(RuntimeException exception, Cache cache, Object key) { logger.</description></item><item><title>使线上 Spring 应用更好部署和调试</title><link>https://kyon.life/post/spring-config/</link><pubDate>Mon, 17 Feb 2020 21:32:03 +0800</pubDate><guid>https://kyon.life/post/spring-config/</guid><description>运行一个配置中心，可以方便快捷的更改线上服务多个实例的配置（通过 git commit&amp;amp;git push），配置中心通过服务发现暴露自己的 IP，client 中无需写死 server 地址，在 k8s 中部署也更自然。
运行一个可视化的应用详情 server，可以直观的看到应用健康监控、应用运行的包的构建时间及代码 commit id，应用当前生效的属性并可以动态修改，应用精确到类的日志级别，并可以动态修改。
要做到以上的事情，主要涉及四个组件的配置：
spring-cloud-config spring-boot-admin spring-zookeeper-discovery spring-boot-actuator 效果展示 配置完成后效果图如下，主要是可视化的应用详情部分的展示，关于配置中心的使用方式的话，目前没有界面，主要就是对 spring-cloud-config server 后端数据的修改，然后 spring 有机制可以让它们动态生效，至少应用重启后可以覆盖 jar 包中的属性配置。
一个美观页面，主要展示了三种信息：
服务运行了多长时间 当前起的服务: configserver 和 cloud-adapter-aws，是从服务的 spring.application.name 取值 每个服务有几个实例，目前本地测试环境起的，都只有一个实例 服务的版本信息，从 pom.xml 文件种读的 &amp;lt;version&amp;gt;0.1.0&amp;lt;/version&amp;gt;
右上角切换到 Applications 的页面，以数字+列表形式展示了服务统计信息，当服务比较多的时候这个页面会更直观一些，另外当一个服务有多个实例时，可以从这个页面区分不同实例进入到详情页面。
这里进入 cloud-adapter-aws 服务的一个实例页面，左侧导航栏有三部分，默认进入 Details 这一项。
页面上我会比较关注的部分，
git 信息，包括 commit id，时间，分支 build 信息，包括版本号，构建时间，当线上出现问题时，可以通过 1，2 这两条信息快速定位到部署对应的包以及代码 健康状态监控，由 /actuator/health 返回的信息稍微规整了一下，可以快速看到依赖的第三方应用比如 mq、zk、db（如果使用了的话） 等组件的健康状态展示出来。另外也可以通过配置包含一些详细信息比如下面的 4 和 5 使用了 spring cloud discovery 的话，会把可以看到的 client 也展示出来 使用了 spring cloud config 的话，会把 config 加载的地址展示出来</description></item></channel></rss>