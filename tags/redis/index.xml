<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>redis on kyon&#39;s wonderland with ❤️</title>
    <link>https://kyon.life/tags/redis/</link>
    <description>Recent content in redis on kyon&#39;s wonderland with ❤️</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Tue, 29 Sep 2020 15:40:36 +0800</lastBuildDate><atom:link href="https://kyon.life/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring 框架缓存故障自动切换</title>
      <link>https://kyon.life/post/dynamic-switch-cache-in-spring/</link>
      <pubDate>Tue, 29 Sep 2020 15:40:36 +0800</pubDate>
      
      <guid>https://kyon.life/post/dynamic-switch-cache-in-spring/</guid>
      <description>现状 缓存只是提高访问速度，应用本身没有很高的并发访问量，缓存不可用时，数据库也能顶住。但是缓存挂掉以后，Spring CacheManager 默认会抛出异常，方法直接就异常退出了。
目标 缓存不可用时，不影响应用正常运行，不影响接口正常返回。
解决方案 方案一 最直接的方案，Spring 定义的 error handler 默认是抛出异常，覆盖 handler 并 catch 住异常不要抛出就可以不影响正常处理流程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class CacheErrorLoggingHandler extends SimpleCacheErrorHandler { private Logger logger = LoggerFactory.getLogger(CacheErrorLoggingHandler.class); private ClientResources clientResources; public void setClientResources(ClientResources clientResources) { this.clientResources = clientResources; } @Override public void handleCacheGetError(RuntimeException exception, Cache cache, Object key) { logger.</description>
    </item>
    
  </channel>
</rss>
