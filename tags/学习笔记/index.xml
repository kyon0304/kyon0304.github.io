<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>学习笔记 on kyon's wonderland with ❤️</title><link>https://kyon.life/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><description>Recent content in 学习笔记 on kyon's wonderland with ❤️</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 01 Sep 2021 14:39:48 +0800</lastBuildDate><atom:link href="https://kyon.life/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>操作系统导论学习笔记（三）</title><link>https://kyon.life/post/ostep-3/</link><pubDate>Wed, 01 Sep 2021 14:39:48 +0800</pubDate><guid>https://kyon.life/post/ostep-3/</guid><description>只有少量的物理 CPU，操作系统如何提供有几乎无限 CPU 可用的假象？
操作系统通过虚拟化(Virutalization) CPU 来提供这种假象。通过让每个程序只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。这就是时分共享(time sharing) CPU 共享技术。
潜在的开销就是性能降低，因为如果 CPU 必须共享，每个进程的运行就会变慢。
要实现 CPU 的虚拟化，操作系统需要提供底层 机制（mechanism） 和高层 策略（policy） 的支持：
机制是一些低级方法或协议，比如上下文切换（context switch），让操作系统可以停止运行当前程序，并在给定的 CPU 上运行另一个程序。 策略是操作系统作出某种决定的算法，比如调度策略（scheduling policy）决定当前 CPU 运行一组待运行程序中的哪一个。 分离机制和策略：机制为 how 提供答案，策略为 which 提供答案，将两者分开可以轻松地替换策略，而不必重新考虑机制。这是一种通用的软件设计原则：模块化。
关键问题：如何高效、可控地虚拟化 CPU
操作系统必须以高性能的方式虚拟化 CPU，同时保持对系统的控制。为此，操作系统会巧妙地利用硬件的支持。
受限的直接执行 基本技巧：受限的直接执行 LDE Limited Direct Execution
「直接执行」是指程序直接运行在 CPU 上
「受限」的体现之一，是 CPU 执行模式区分「用户模式 user mode」 和 「内核模式 kernel mode」，用户模式下，程序执行是受限制的，比如不能执行特权操作的（比如访问磁盘 I/O）。
LDE 协议的具体实现方式：
操作系统启动时，内核使用特权指令设置陷阱表 (trap table)，告知硬件接收到特定指令时，到哪里寻找需要执行的程序。 用户程序运行在用户模式下，发出系统调用后，硬件检测到变化，保存当前程序的状态（比如寄存器入栈），转为内核模式，查询陷阱表，然后跳转到对应的内核程序处执行。内核执行完程序后，调用返回用户模式指令，硬件恢复寄存器，转为用户模式，回到应用程序中继续执行。 系统调用类似过程调用，但隐藏在系统接口里的实现，是著名的陷阱指令。为了仔细遵循与内核一致的调用约定（例如将参数放在知名位置），库函数的系统调用部分是用汇编语言手动实现的。
LDE 协议的两阶段实现时间线</description></item><item><title>操作系统导论学习笔记（二）</title><link>https://kyon.life/post/ostep-2/</link><pubDate>Wed, 01 Sep 2021 13:46:35 +0800</pubDate><guid>https://kyon.life/post/ostep-2/</guid><description>进程 操作系统为正在运行的程序提供的抽象，就是进程。
操作系统也是一种应用程序，会使用数据结构保存进程相关的信息。比如保存正在运行的进程的一些附加信息，保存就绪进程列表，跟踪阻塞进程的信息，以便在合适的时机进行唤醒。进程列表这种数据结构，有时也会被称为 程序控制块 PCB Program Control Block
在任何时刻，都可以清点进程在读取和修改什么内容，机器的哪部分会对进程造成影响，我们称之为进程的机器状态（machine state）
机器状态包括：
内存：程序执行的指令和读取及修改的数据，进程可访问的内存称为进程的地址空间 通用寄存器 一些特殊寄存器 PC 指针：程序正在执行的指令 栈指针 stack pointer，帧指针 frame pointer 用于管理函数参数栈、局部变量和返回地址 I/O 信息： 程序访问的持久化存储设备 现代系统进程都会提供的 API
创建：程序变成进程的过程 销毁：如果程序不肯自己退出，操作系统提供了接口让用户结束进程 等待：有时等待进程停止运行是有用的 其他控制：除等待和销毁外的其他控制接口，比如暂停执行和恢复执行 状态：查看进程状态 操作系统创建进程
从磁盘加载代码和静态数据（比如初始化变量）到内存中 尽早加载 eagerly load 惰性加载 lazily load 只加载执行到的片段，需要内存分页和交换机制支持 分配内存，提供给程序的运行时栈使用，也可能会使用参数（argc, argv）初始化栈 也可能会给程序分配堆内存 其他初始化任务，特别是 I/O 相关的 在 Unix 中，所有进程都默认有 3 个打开的文件描述符：标准输入、标准输出和错误输出 启动程序：通过跳转到 main() 例程，操作系统将 CPU 的控制权交到新创建的进程中，从而程序开始执行 进程的 3 种状态及相互转换</description></item><item><title>操作系统导论学习笔记（一）</title><link>https://kyon.life/post/ostep-1/</link><pubDate>Tue, 31 Aug 2021 22:45:12 +0800</pubDate><guid>https://kyon.life/post/ostep-1/</guid><description>为了让程序运行变得更容易，操作系统出现了。操作系统完成的事情包括，允许多个程序同时运行、让程序共享内存、让程序能够与设备交互等。操作系统负责确保系统既易于使用又正确高效的运行。操作系统通过虚拟化（virtualization）做到这一点，操作系统将物理资源（如 CPU、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机(virtual machine)
设计和实现操作系统的目标 提供高性能，尽可能降低操作系统的性能开销 minimize the overhead 在应用程序之间以及操作系统和应用系统之间提供保护 protection 让进程间彼此隔离是实现保护的关键 isolation 保证高可靠性 reliability 能源效率 energy efficiency, 安全性 security, 移动性 mobility 操作系统的 3 个“简单”部分 虚拟化 virtualizing 持久性 persistence 并行 concurrency 虚拟化 virtualizing 虚拟化又分为虚拟化 CPU 和虚拟化内存。
虚拟化 CPU
在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟CPU的假象。将单个CPU（或其中一小部分）转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU（virtualizing the CPU）
虚拟化内存
每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。但实际情况是，物理内存是由操作系统管理的共享资源。
持久化 persistence 内存 DRAM 中的数据是易失的，如果断电或系统崩溃，内存中的数据都会丢失。因此我们需要硬件和软件支持来持久地存储数据。
硬件以某种输入/输出设备（Input/Output, I/O）的形式出现。
操作系统中管理磁盘的软件通常称为文件系统（file system）。因此它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。
关键问题：如何持久地存储数据
文件系统是操作系统的一部分，负责管理持久的数据。持久性需要哪些技术才能正确地实现？需要哪些机制和策略才能高性能地实现？面对硬件和软件故障，可靠性如何实现？
并行 concurrency 关键问题：如何构建正确的并发程序
如果同一个内存空间中有很多并发执行的线程，如何构建一个正确工作的程序？操作系统需要什么原语？硬件应该提供哪些机制？我们如何利用它们来解决并发问题？
操作系统的简单历史 早期操作系统：只是一些库 引入保护机制：借助硬件的帮助，区分用户模式和内核模式 多道程序 multiprogram: 提高 CPU 执行效率，避免 I/O 处理拖慢 CPU 执行。出现 Unix 摩登时代：出现个人计算机，遗憾的是，对于操作系统来说，个人计算机起初代表了一次巨大的倒退，因为早期的系统忘记了（或从未知道）小型机时代的经验教训。幸运的是，经过一段时间的苦难后，小型计算机操作系统的老功能开始进入台式机。</description></item><item><title>Philosophy of Software Design 第三章 仅仅能工作的代码是不够的（编程时的战略 vs 战术思维）</title><link>https://kyon.life/post/philosophy-of-software-design-3/</link><pubDate>Mon, 24 Feb 2020 11:45:01 +0800</pubDate><guid>https://kyon.life/post/philosophy-of-software-design-3/</guid><description>好的系统设计最重要的元素之一是完成编程任务时所采取的思考方式。许多组织鼓励使用战术性思维，专注于尽快使功能上线工作。然而，如果想获得好设计，则必须采取战略思维，在简洁的设计和修复问题上投入更多时间。这章讨论了为什么采用战略思维可以获得更好的设计，而且从长远来看，实际上要比战术思维更节省时间。
3.1 战术式编程 大多数程序员采用我称为战术式编程的方式进行软件开发。这种方式中，主要关注点是得到能工作的东西，比如一个新功能或修复一个 bug。第一眼看去，似乎完全合理：还有什么能比写出可以工作的代码更重要呢？然而，战术式编程很明显不能产生一个好的系统设计。
战术式编程的问题在于短视。采用战术式思维编程时，你就会尽快地完成一项任务。可能面临着硬性规定的截止时间。最终，为未来做计划的优先级就会变低。你不会在寻找最好的设计上花费太多时间；你只是想要尽快获得可以工作的代码。你会自我催眠，认为如果可以更快地完成当前任务，那么增加一点复杂度或者混入一两个不和谐因素也没什么问题。
这就是系统如何变复杂的。正如前一章中讨论的那样，复杂性是增量的。并不是某一个特定的问题，而是数十或数百个小问题的积累使得系统变复杂了。如果你采用战术式编程，每一个编程任务都会向这些复杂性做贡献一些问题。每一个问题可能看上去都是为了快速完成当前任务的合理折中。然而，复杂性会迅速积累，尤其是如果每个人都采用战术式编程的话。
不久之后，一些复杂性就会开始导致问题，你将会开始希望当时没有走捷径。但是，你仍会告诉自己，使得下一个功能尽快工作要比反过头来重构已有代码重要得多。长远来看重构可能可以帮得上忙，但是绝对会拖慢当前任务的进度。所以，对于碰到的任何问题，你就会寻找可以解决它的快速补丁，而这又会在将来需要更多的补丁。很快代码就会变成一团糟，但是此时想要清理代码的话将耗费数月的工作。你的日程不可能负担得起这样的延迟，而且修复其中一两个问题看上去也不会有什么效果，所以你会仍旧保持战术式编程。
如果你曾经在一个大型软件项目中工作过很久，我猜你曾经在工作中见过战术式编程并且经历过它带来的问题。一旦你开始采用这种方式，就很难做出改变。
几乎每个软件开发公司都至少有一名把战术式编程发挥到极致的开发人员：战术式飓风。战术式飓风是一名高产的程序员，他地代码产出速度比其他人快得多，但是完全以战术式思维的方式工作。当涉及实现一个快速功能时，没有人可以比战术式飓风更快的完成。在一些公司中，管理层将战术式飓风视为英雄。然而，战术式飓风会留下一系列破坏痕迹。他们很少被将来必须和他写的代码打交道的工程师视为英雄。通常，其他工程师必须清理战术式飓风造成的混乱，这会使得这些工程师（真正的英雄）看上去比战术式飓风的进度更慢。
3.2 战略式编程 成为一个好的系统设计师的第一步是要意识到 仅仅能工作的代码是不够的。 为了完成当前任务而引入不必要的复杂性是不可接受的。更重要的是系统的长期结构。任何系统中的大多数代码都是在已有代码的基础上扩展而来的，所以作为开发者最重要的工作是为那些将来的扩展提供便利。因此，不应当把“可以工作的代码”当作首要目标，尽管你的代码当然必须可以工作。你的首要目标必须是获得好设计，然后也恰好可以工作。这就是 战略式编程。
战略式编程要求有投资的思维。相较于采取最快的方式完成当前项目，你必须投资一些时间提升系统的设计。这些投资短期看会稍微拖慢你的进度，但是长期来看它们会加速你的开发，如图 3.1 所示。
一些投资是主动的。比如，为每个新建的类多花一点时间找到简单的设计是值得的；与其实现蹦到脑子里的第一个主意，不如尝试一些其他的设计并选择其中最简洁的。试着想象一下未来系统可能会向哪些方向改变，并且保证你的设计可以使得这些改变会很容易。编写良好的文档是主动投资的另外一个例子。
其他投资将会是被动的。不管你前期投资了多少，你的设计决定不可避免地会出现错误。随着时间流逝，这些错误会变明显。当你发现了一个设计问题，不要忽略它或仅仅通过打补丁解决；花费一些额外的时间来修复它。如果采用战略式编程，你将会对系统设计持续性地做出小改善。这是战术式编程的反面，那种方式下你会持续性地增加复杂性并在将来引发问题。
3.3 投资多少时间？ 所以，投资的时间正确数量是多少呢？巨大的前期投资，比如尝试设计整个系统，是低效的。这是瀑布式方法，而且我们知道它不奏效。理想的设计倾向于随着你获得系统的经验而一点点地出现。因此，最好的方式是在连续的基础上作出大量的投资。我建议花费大约占开发时间的 10-20% 在前期投资上。这个数量足够小，不会显著影响你的日程安排，但是又足够大，可以随着时间获得明显的收益。因此你最初的项目花费的时间要比纯粹的战术式方式长 10-20%。这个额外的时间会导致更好的软件设计，并且几个月内你就会开始享受这些好处。不久之后，你的开发速度就会比当时以战术式编程的人快至少 10-20% 。到这个时候，你的投资就会变成免费的了：从你过去的投资中的获益将会节省足够多的时间覆盖将来的投资。你将会快速地从初始的投资中恢复。图 3.1 展示了这种现象。
__图 3.1__：开始，战术式编程会比战略式编程进度更快。然而，战术方式下复杂性会更快地积累。随着时间流逝，战略方式进度会更快。注意：这张图只是定性的说明；我不知道任何可以对这个曲线进行精确测量的经验
相反，如果你采用战术式编程，你将会更快地完成第一个项目，但是随着时间流逝，你的开发速度会随着复杂性累积而变慢。你将会很快地将开始节省的时间还回去，而且在这个系统剩下的生命中，你的开发速度会越来越慢。如果你从未在糟糕的代码基础上工作过，和其他有过这种经历的人聊一聊；他们会告诉你糟糕的代码质量至少会拖慢 20% 的开发速度。
3.4 初创企业和时间投资 在一些环境中有着强大的力量反对战略式方式。比如，早期的初创企业有着将他们的早期版本发布出去的巨大压力。在这些公司中，看上去即使是 10-20% 的投资也支付不起。最终，许多初创企业采取了战术方式，在设计上花费的时间很少，清理出现的问题时花费的时间甚至更少。他们用这样的想法将这些行为合理化：如果他们成功了，他们会有足够的钱雇佣更多的工程师来做清理。
如果你在有这种倾向的公司中，你应当已经意识到，一旦代码库变混乱，想要修复基本是不可能的。在这个产品的生命中你可能需要支付很高的研发花费。而且，好（或坏）设计的报应来得非常快，所以，战术方式很可能甚至无法加速你第一个产品的发布。
另外一件需要考虑的事情是，公司成功的最关键的因素之一是它的工程师的质量。降低开发花销的最好的方式是雇佣厉害的工程师：他们的成本不比平庸的工程师多多少，但是他们有着高得多的产出。然而，最好的工程师非常关注好的设计。如果你的代码库一团糟，事情会传出去，你会更难进行招聘。最终，你很可能只能拥有平庸的工程师。这回增加未来的花费，而且很可能会导致系统结构进一步降级。
Facebook 就是一个鼓励战术编程的初创企业的例子。很多年来这家公司的座右铭是“快速行动并打破东西。”刚刚从大学毕业的新入职工程师被鼓励立即深入公司的代码库；工程师在他们入职的第一周就向线上提交代码曾经是很常见的。积极的一面是，Facebook 作为一家给员工赋权的公司而闻名。工程师有着巨大的自由，基本没有什么规则和约束阻碍他们。
Facebook 作为一家公司曾经非常成功，但是它的代码库由于公司的战术方式而遭受了损失；大多数代码都不稳定而且难以理解，基本没有注释和测试，使用时非常痛苦。随着时间流逝，这家公司意识到它的文化是不可持续的。最终，Facebook 把座右铭变为“在坚实的基础架构上快速行动”来鼓励它的工程师在好的设计上投资更多时间。Facebook 是否能成功地清理数年来战术式编程累积地问题还有待观察。
对 Facebook 讲句公道话，我应当指出 Facebook 的代码可能不比初创企业的平均水平差多少。初创企业中战术式编程是家常便饭；Facebook 只是恰好是一个特别明显的例子。
幸运的是，采用战略方式也可能在硅谷中成功。Google 和 VMware 差不多和 Facebook 同时起家，但是这两家公司都拥抱了更战略化的方式。它们都很重视代码的质量和好的设计，而且都基于可信赖的软件系统构建了解决复杂问题的精致的产品。这些公司强烈的工程文化在硅谷变得出名。很少能有别的公司可以在招聘顶级人才中竞争得过它们。
这些例子表明公司可以以任一种方式成功。然而，在关注软件设计并拥有干净代码库的公司工作要有趣得多。
3.5 结论 好的设计不是免费的。你必须持续性的进行投资，这样小的问题就不会积累成大问题。幸运的是，好设计最终会偿付它自己，而且比你认为的要更快。
采用战略方式时从一而终是非常重要的，而且要把投资当作今天要做的事情，而不是明天。当你进入一个紧张的工期，把清理工作推到这个工期结束后会非常具有诱惑性。然而，这是一个滑坡；当前紧张的工期结束后，几乎总是会有另外一个，然后又是另外一个。一旦你开始推迟设计提升，推迟很可能会变为永久的，然后你的文化会滑向战术方式。你等待解决设计问题越久，问题就会变得越大；解决方案会变得越吓人，这又会使得推迟解决变得更容易接受。最有效的方式是每个工程师都为好的设计持续性地做出投资。</description></item><item><title>Philosophy of Software Design 第二章 复杂度的天性</title><link>https://kyon.life/post/philosophy-of-software-design-2/</link><pubDate>Wed, 19 Feb 2020 12:15:39 +0800</pubDate><guid>https://kyon.life/post/philosophy-of-software-design-2/</guid><description>这本书是关于如何设计软件系统使得它们的复杂度最小化。第一步是了解敌人。到底什么是“复杂性”？你怎么知道一个系统是不必要的复杂？什么会导致系统变复杂？这章会在较高层级解决这些问题；余下的章节会就具体结构特征向你展示如何在较低层级识别复杂度。
识别复杂性是设计技能中一项关键的能力。它使得你可以在投入大量精力前发现问题，并且在许多可选项中做出好选择。分辨出一个设计是否简洁要比创造一个简洁的设计容易，但是一旦你可以识别出一个系统过于复杂，你就可以使用这个能力来指导你的设计哲学向着简单性出发。如果一个设计看上去很复杂，尝试一种不同的方式然后看看是否变简单了。随着时间流逝，你会注意到一些特定的技术会得到更简单的设计，另外一些则和复杂性相关。这将使得你能更快地产出更简洁的设计。
本章也会给出一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节会使用本章的材料来评判各种不同的改善方法和结论。
2.1 定义复杂性 为了这本书的目的，我以一种实践方式定义“复杂性”。复杂性是和软件系统结构相关的、使得理解和修改系统更困难的任何东西。 复杂性可能会以很多形式出现。比如，可能难以理解一段代码是如何运行的；可能一点小的改进需要花费很大精力，或者为了做出改进需要修改系统的哪些部分难以确定；可能很难在不引入其他问题的情况下修复一个 bug。如果很难理解和修改一个软件系统，那么它就是复杂的；如果很容易理解和修改，那它就是简单的。
也可以从成本和收益的角度考虑复杂性。在复杂系统中，哪怕是实现一个很小的改进都需要花费很多工作。在简单系统中，可以用更少的工作完成更大的改进。
复杂性是开发者在尝试完成一个特定目标时在特定时间点的经历。并不一定和系统整体的大小或功能相关。人们经常用“复杂（complex）”一词来描述有着复杂（sophisticated）功能的大型系统，但是如果这样的系统开发很容易上手的话，那么，从本书的角度来看，并不复杂（complex）。当然，几乎所有大型和复杂（sophisticated）的软件系统实际上也难以开发，所以它们也符合我这里复杂的定义。但是这并不一定是事实。小型并不复杂（unsophisticated）的系统也有可能非常复杂（complex）。1
复杂性由最常见的活动决定。如果系统中包括一些非常复杂的部分，但是这些基本不会用到，那它们对系统整体的复杂性几乎没影响。用粗略的数学方式来表示：
$$C = ∑c_pt_p$$
系统整体复杂性（C）由每部分的复杂性 （$c_p$）加权开发者在这部分花费的时间（$t_p$）决定。把复杂性隔离在一个从不会被看到的地方基本就和完全消除了复杂性一样。
相较于编写者，复杂性对阅读者来说更明显。如果你编写了一段对你来说似乎很简单的代码，但是其他人认为它复杂，那么它就是复杂的。当你发现你处于这样的境况中，请其他开发者来看一下为什么他们觉得代码很复杂就很值得一试；在你和他们不同的观点中很有可能学到有趣的东西。作为开发者的工作不仅仅是写出你觉得容易的代码，也要让其他人觉得容易。
2.2 复杂性的征兆 复杂性通过三种一般的方式表现出来，下面的段落将会描述到。每一种都会使得完成研发任务变得困难。
__图2.1：__ 网站的每个页面都会展示有颜色的横幅。(a) 中横幅的背景色是在每个页面中显示指定的。(b) 中共享变量保存背景色的值，每个页面都指向这个变量。(c) 中一些页面会展示额外的颜色表示强调，这个颜色是背景色带阴影的较暗的转换；如果背景色变化了，强调色也必须跟着变化。
放大改变： 复杂性的第一个征兆是，一个看上去简单的改变需要在许多不同的地方修改代码。比如，考虑有着不同页面的网站，每一个页面都会展示有着背景色的横幅。在很多早期网站中，颜色是由每个页面显示地指定的，如图 2.1(a)。为了改变这个网站的背景色，开发者可能需要手动地修改每个已有页面；对于有着上千张页面的大型网站来说这几乎是不可能的。幸运的是，现代的网站使用了图 2.1(b) 中的方式，横幅颜色在一个集中的地方一次性指定，所有页面都指向这个共享的值。使用这种方式时，整个网站的横幅颜色变化可以由单个修改完成。好的设计的目标之一是，减少每个设计决定会影响到的代码数量，这样修改设计时不需要改动很多代码。
心智负担： 复杂性第二个征兆是心智负担，心智负担是指开发者为了完成任务需要了解多少东西。更高的心智负担意味着开发者不得不花费更多时间学习必需了解的信息，而且可能会由于他们遗漏了一些重要信息而增加出现 bug 的风险。比如，C 中分配内存的函数返回指向内存的指针，并且假设调用者会释放内存。这增加了使用这个函数的开发者的心智负担；如果开发者没能释放内存，那么就会出现内存泄漏。如果可以重构系统使得开发者无需关心内存释放（分配内存的模块同时负责释放它），就可以降低心智负担。心智负担以多种方式出现，比如有许多方法的 API，全局变量，不一致性，模块间依赖。
系统设计者有时候认为可以用代码行数衡量复杂性。他们认为如果一个实现比另外的短，那么肯定就更简单；如果只需要很少几行就可以做出改变，那这个改变肯定很容易。然而，这个视角忽略了和心智负担有关的成本。我曾经见过只需要几行就可以完成一个应用的框架，但是想要搞懂这几行做了什么事情却及其困难。有时候需要更多行代码的方式其实更简单，因为它降低了心智负担。
未知的未知： 复杂性的第三个征兆是，为了完成任务需要修改哪些代码或者开发者需要了解哪些信息并不明显。图 2.1(c) 展示了这个问题。网站使用集中变量来决定横幅背景色，所以看上去很容易修改。然而，一些网页使用了带阴影加深的背景色来表示强调，而这个加深的颜色是在每个页面单独指定的。如果背景色变化了，那强调色也必须相匹配地跟着变化。不幸的是，开发者不太可能意识到这个颜色的存在，所以他们可能修改了集中变量 bannerBg 但是没有更新强调色。即使开发者意识到了这个问题，哪些页面使用了强调色也不明显，所以开发者不得不搜索网站中的所有页面。
复杂性的三种表现方式中，未知的未知是最糟糕的。未知的未知意味着你需要了解一些东西，但是你却无法知道需要了解什么，或者甚至这些东西是否存在。在你修改后，直到出现 bug 之前都无法知道。改变放大很烦人，但是只要知道需要修改哪些代码，一旦完成修改系统还是可以工作。类似的，高的心智负担会增加做出改变的成本，但是如果知道哪些信息需要掌握，改变仍旧很可能是正确的。而未知的未知的情况，你将不知道需要做什么，或者提议的方案是否可以工作。唯一可以确定的方式，是阅读系统的每一行代码，这对任何规模的系统都是不切实际的。即使这样也还不够，因为修改可能依赖于一个从未记录的微小的设计决定。
对于系统来说，好设计的最重要的目标之一是使系统变得浅显易懂。这是高心智负担和未知的未知的对立面。在浅显易懂的系统中，开发者可以快速了解已有代码是如何工作的以及做出修改需要什么。浅显易懂的系统中，开发者可以快速的猜出要做什么，不需要非常认真地思考，而且还可以对猜测很有信心。第十八章讨论了使得代码更浅显易懂的技术。
2.3 复杂性的原因 既然你已经知道了复杂性的高层级的征兆，还有为什么复杂性会使得软件开发变困难，下一步就是搞懂什么导致了复杂性，这样我们就可以在设计系统时避免这些问题。复杂性是由两种东西导致的：依赖和模糊。这部分从高层次讨论了这些因素；余下的章节会讨论它们如何与低层次的设计决定相关。
从本书的目的来说，当一段代码无法单独被理解和修改时，就说明存在依赖；这段代码和其他代码以某种方式相关，如果这段代码修改了，也必须考虑和/或修改其他代码。在图 2.1(a) 的网站例子中，背景色创建了所有页面之间的依赖关系。所有页面必须有相同的背景，所以如果一个页面的背景修改了，那么所有其他的页面也必须修改。依赖的另外一个例子出现在网络协议中。一般来说，协议的发送方和接收方代码是独立的，但是它们都必须遵循这个协议；修改发送方的代码几乎总是要求接收方也做出相应修改，反过来也一样。方法的签名创建了这个方法的实现和调用者之间的依赖关系：如果这个方法新增了一个参数，这个方法的所有调用者都必须加以修改来指定这个参数。
依赖是软件中一个基础部分，不能被完全消除。实际上，在软件设计过程中我们会故意引入依赖。你每次新增类的时候，都会创建围绕这个类的 API 的依赖。然而，软件设计的目标之一是减少依赖，并且尽量保持依赖简单和明显。
考虑网站的例子。在每个页面中单独指定背景色的老网站中，所有的网页互相依赖。新网站通过在一个集中的地方指定背景色并提供 API 使得每个页面渲染时可以获取到颜色解决了这个问题。新网站消除了页面之间的依赖，但是创建了围绕获取背景色的 API 的新依赖。幸运的是，新依赖更明显了：每个网页依赖于 bannerBg 是很明显的，开发者可以很容易的找到所有使用这个变量的地方。更进一步的，编译器可以帮助管理 API 依赖：如果共享变量的名字变了，仍然使用原来名字的代码会报编译错误。新的网站用一个更简单更明显的依赖替换了原来不明显、难以管理的依赖。
复杂性的第二个原因是模糊。当重要信息不明显时，模糊就出现了。一个简单的例子是，变量名过于简单，无法携带很多有用信息（比如 时间）。或者，变量的文档可能没有它的单位，所以只能到使用这个变量的地方查看。当依赖的存在不明显时，模糊经常和依赖相关。比如，如果系统中要新增一个错误状态码，可能也需要在存储了每个状态码的文字消息的表中新增一条记录，但是对于看状态定义的程序员来说，消息表的存在可能不够明显。不一致也是模糊的一个重要来源：如果相同的变量名用于两种不同目的，对开发者来说，一个具体的变量服务于哪个目的就不明显了。</description></item><item><title>Philosophy of Software Design 第一章 介绍（一切都与复杂性有关）</title><link>https://kyon.life/post/philosophy-of-software-design-1/</link><pubDate>Wed, 19 Feb 2020 10:16:53 +0800</pubDate><guid>https://kyon.life/post/philosophy-of-software-design-1/</guid><description>编写软件是人类历史上最纯粹的创造性活动。程序员不受实践限制的约束，比如物理定律；我们可以创造有着现实世界中不可能存在的行为的令人兴奋的虚拟世界。编写程序不像芭蕾或篮球那样要求有很棒的身体技能或协调性。编写程序所需要的是创造性思维以及组织你的想法的能力。如果你可以想象出一个系统，那么你就有可能在电脑程序中把它实现出来。
这表明编写软件时最大的限制是对我们正在创造的系统的理解能力。随着一个程序不停演进并获得更多功能，它会变得复杂，组件之间会有不起眼的依赖。时间流逝，复杂度会累积，程序员在修改系统时，越来越难以把所有相关的因素都记在脑子里。这就会拖慢研发速度，并且导致 bug 产生，然后形成一个恶性循环。任何程序的复杂度都会不可避免的变高。越大型的程序，越多的人参与开发，就越难以控制复杂度。
好的开发工具可以帮助我们处理复杂度，过去的几十年中有许多很厉害的工具被创造了出来。但是仅仅使用这些工具，我们能做到的事情是有限制的。如果我们想要把编写软件变得简单，使得构建强大的系统变得更容易，我们必须找到使软件更简单的方式。尽管我们尽了最大的努力，复杂度还是会随着时间增长，但是更简单的设计允许我们在复杂度不可控之前构建出更大型更强大的系统。
控制复杂度有两种通用的方式，这本书都会讨论。第一种方式使通过使代码更简单更清晰来消除复杂度。比如，通过去除特殊场景或使用一致的标识可以减少复杂性。
第二种方式是封装复杂性，这样程序员可以在不完全了解它的复杂性的情况下基于这个系统进行开发。这种方式被称作 模块化设计。在模块化设计中，一个软件系统划分为不同的模块，比如面向对象语言中的类。模块被设计为相对独立的，这样程序员可以在不了解其他模块细节的情况下开发当前模块。
由于软件是如此具有延展性，所以软件设计是一个会横跨整个软件系统生命周期的持续的过程；这使得软件设计不同于物理系统比如建筑、轮船或桥梁的设计。然而，软件设计并不是一致被这样看待的。对于编程的历史上大多数时候，设计都集中于项目的开始阶段，就像其他工程原则一样。这种方式的极端被称为 瀑布模型，项目被划分为分散的阶段比如需求定义、设计、开发、测试和维护。在瀑布模型中，每个阶段都在下一个阶段开始前结束；大多数情况下，每个阶段是由不同的人来负责。整个系统在设计阶段一次性设计完成。这个阶段结束时设计就固定了，余下的阶段只是充实和设计这个设计。
不幸的是，瀑布模型对软件来说几乎无法奏效。软件系统本质上要比物理系统更复杂；对于大型软件系统来说，在没有搭建任何东西之前，不可能将设计考虑地足够全面。结果，最初的设计会有许多问题。在进行实现之前这些问题都不会明显地暴露出来。然而，这时瀑布模型无法应对重大设计的变更（比如，设计者已经调去其他项目）。因此，程序员会尝试在不改变整体设计的情况下修补问题。这会导致复杂度爆炸性增长。
由于这些问题的存在，当今的大多数软件开发项目采用一种增量的方式，比如 敏捷开发，最初的设计只关注总体功能的一小部分。这一部分被设计、实现，然后被评估。发现并更正原来设计中的问题，然后设计、实现和评估更多的功能。每次迭代都会暴露已有设计中的问题，并在设计下一部分的功能前修复。通过以这样的方式将设计扩散出去，最初设计中的问题可以在系统仍旧比较小型时修复；后面的功能可以从早期功能开发的经验中获益，所以出的问题会变少。
增量的方式对软件奏效是因为软件具有足够的延展性，允许在实现的过程中出现重大的设计变更。相反，对物理系统来说，重大的设计变更会更具有挑战性：比如，在建造过程中修改桥墩的数量是不切实际的。
增量研发意味着软件设计永远未完成。在系统的生命中设计持续存在：开发者应该一直考虑设计问题。增量研发也意味着持续的重新设计。系统或组件的初始设计几乎从来不是最好的；经验会不可避免地展示出完成这件事情的更好方式。作为一名软件开发者，应该始终寻找提升你正在开发的系统的设计的机会，而且应该为设计改进预留出一部分时间。
如果软件开发者应该使用考虑设计问题，并且降低复杂性是软件设计最重要的元素，那么软件开发者应该始终考虑复杂性。这本书就是关于如何使用复杂性指导软件设计的。
这本书有两个整体目标。第一个是描述软件复杂性的天性：“复杂性”意味着什么，为什么重要，以及如何识别出程序中存在不必要的复杂性？这本书第二个，而且更具挑战性的目标是给出在软件开发期间可以用来最小化复杂性的技术。不幸的是，并没有能够保证很棒的软件设计的简单的处方。相反，我会给出一系列哲学化的高层的概念，比如“类应该有深度” 或者 “通过定义使得错误不复存在”。这些概念可能无法立即区分出最好的设计，但是你可以使用它们比较不同的设计选择，并指导你在设计领域的探索。
1.1 如何使用这本书 这里讨论的设计原则很多都在一定程度上抽象，所以不看实际的代码可能会很难理解。寻找既足够小到可以放到书中又足够大到可以展示问题的例子非常困难（如果你遇到了好例子，请把它们发送给我）。所以，学习如何应用这些原则，只看这本书可能不够。
使用这本书最好的方式是和代码审查联合起来。当你阅读别人的代码时，考虑它是否遵循了这里讨论的概念，以及如何影响代码的复杂度。在别人的代码中更容易看到设计问题。你可以用本书中描述的红色警告来识别问题并且提出改进建议。审查代码也会使你接触到新的设计方式以及编程技巧。
提升你的设计技能的最好的方式之一是学习识别 红色警告：一段代码可能比它实际需要的更复杂的信号。在本书的课程中，我会指出和每个主要设计问题相关的表示问题出现的红色警告；最重要的几个在书的最后做了总结。当你编码时可以使用：当你看到一个红色警告，停止工作并寻找可以消除问题的其他设计。当你第一次尝试这种方式时，在找到可以消除红色警告的设计前，可能不得不尝试好几种设计。不要轻易放弃：在修复问题前尝试地越多，你学到的越多。随着时间流逝，你会发现代码中的红色警告越来越少，你的设计变得越来越简洁。你的经验也会向你展示其他红色警告，你可以用来识别设计问题（我会很乐意听到你新发现的这些红色警告）。
当应用本书中的理念时，应当注意节制和谨慎。每条规则都有例外，每个规范都有限制。如果你把每个设计理念都发挥到极致，可能最终会陷入困境。漂亮的设计反应了理念和实现之间较量的平衡。有几个章节中包含名为“过度实践”的部分，描述了如何发现你已经过度了。
这本书几乎所有例子都是 Java 或 C++ 的，大多数讨论都是针对面向对象语言中的设计类。然而，这些理念也可以很好的应用于其他领域。几乎所有和方法有关的理念也可以应用于没有面向对象功能的语言中的函数，比如 C。设计理念也可以应用于模块而不是类，比如子系统或网络服务。
有了这些基础以后，让我们更细致地讨论是什么导致了复杂性，以及如何使软件系统更简单。</description></item><item><title>Philosophy of Software Design 第十一章 设计两次</title><link>https://kyon.life/post/philosophy-of-software-design-11/</link><pubDate>Fri, 14 Feb 2020 10:47:48 +0800</pubDate><guid>https://kyon.life/post/philosophy-of-software-design-11/</guid><description>设计软件是很难的，所以当你考虑如何构建一个模块或系统时，不太可能第一个想法就会产生最好的设计。如果对每个主要的设计决定都多考虑几个选项，会得到一个好得多的结果：设计两次。
假设你正在设计图形化文本编辑器中管理文本的类。第一步是定义这个类由编辑器中其他部分使用的的接口；与其使用第一个蹦到脑子里的主意，不如多考虑几种可能性。其中一个选择是面向行的接口，插入、修改和删除整行的文本。另外一个选择是基于单个字符的插入和删除接口。第三个选择是面向字符串的接口，对可能跨越行边界的任意范围的字符进行操作。不需要把每个选项的所有功能特性都确定下来；到目前为止，把几个重要的方法大概轮廓勾勒出来就足够了。
尝试选择和其他几种有本质区别的方式；这样你可以学到更多。即使你很确定只有一种合理的方式，也要考虑一下第二种设计方式，不管你认为它会有多糟糕。思考那个设计的弱点并且把它和其他设计的功能做对比是很有启发性的。
当你粗略地描绘出几种不同的设计后，列一个每个设计的优缺点的表格。最重要的考量是，这个接口对高层的软件来说是否易用。在上面的例子中，面向行和面向字符的接口都需要使用文本类的接口做额外的工作。使用面向行的接口时，当遇到部分或跨行的操作比如剪切和复制选区时，高层的软件需要拆分和合并行。使用面向字符的接口时，对于需要修改多个字符的操作需要循环实现。另外也需要考虑如下几种因素：
其中一种选择比其他有着更简单的接口吗？在文本类的例子中，所有的文本接口都差不多简单。 其中一个接口比其他更通用吗？ 使用其中一个接口的实现会比其他更高效吗？在文本类的例子中，面向字符的接口很可能会比起另外的慢很多，因为它要求每一个字符都调用文本类一次 当你比较过几种不同的设计以后，你将可以更好地确定最佳设计。最好的选择可能是可选项中的一种，或者你可能发现可以把多个选项的功能组合成一个新的设计，会比原来的选择更好。
有时每个选择都不太好；当这种情况发生时，考虑一下能不能想到另外的方案。用你在原有选择中发现的问题来驱动新的设计。如果你正在设计文本类并且只想到了面向行和面向字符的这两种设计方式，你可能会注意到，这两种方式用起来都很别扭，因为它们要求高层软件做额外的文本操作。这是一个红色警告：如果需要有一个文本类，那么它应该处理所有和文本相关的操作。为了消除额外的文本操作，文本接口应该和高层软件中的操作更匹配。这些操作并不总是对应到单个字符或单行。这条推理应该引导你得到一个面向范围的 API，这会消除之前设计中的问题。
设计两次的原则可以应用在系统中的许多层级。对于模块来说，你可以先用这个原则来选择接口，像上面描述的那样。然后当你设计实现时可以再次应用这个原则：对于文本类来说，你可能考虑过各种实现比如行的链表，固定长度的字符块，或者“gap buffer”。设计实现时的目标和设计接口时并不一样：对于实现来说，最重要的是简洁和性能。在设计系统的高层时多探索几种可能性也是很有用的，比如当选择用户界面的功能时，或者将系统拆解为主要模块时。在每个例子中，如果能够比较几个不同的选择就可以更容易发现最好的方案。
设计两遍并不需要占用非常多额外的时间。对于一个小模块比如类来说，你可能都用不到一两个小时来考虑可选项。相比于在实现类时你需要花去好几天甚至好几个星期，这是非常少的时间了。最开始的设计实验很可能最终会有助于得到一个更好的设计，收益会远大于在设计两遍时花费的时间。对于更大的模块，最开始的设计探索会花费更多的时间，但是实现也会更慢，而且更好的设计的收益也会更高。
我注意到设计两遍的原则有时候对非常聪明的人来说很难接受。当他们成长时，聪明人发现他们关于任何问题的第一个快速的想法都足够好；没有必要再考虑第二种或者第三种可能。这就培养了一种糟糕的工作习惯。然而，当这些人更年长一些，他们不断提升进入有着越来越难的问题的环境中。最终，每个人都会到达第一个想法不够好的地步；如果你想要获得真正厉害的结果，就必须考虑第二种可能，或者可能是第三种，不管你有多聪明。大型软件系统的设计就属于这个分类：没有人可以第一次尝试就把它做对。
不幸的是，我经常看到坚持实现第一个想法的聪明人，这导致他们无法发挥真正的潜能（同时也使得和他们共事令人沮丧）。或许他们下意识地认为“聪明人可以第一次就做对”，所以如果他们尝试不同地设计就会表明他们其实并不聪明。不是这样的。不是你不聪明；而是问题真的很难！而且，这是一件好事：相比完全不用动脑的简单问题，解决需要仔细思考的难题要有趣得多。
设计两遍的方式不仅提高了你的设计，而且可以提高你设计的技能。设计和比较不同方式的过程会教给你影响设计好坏的因素。随着时间的推移，排除糟糕的设计并磨练真正厉害的设计对你来说会越来越容易。</description></item><item><title>Philosophy of Software Design 第十章 通过定义使得错误不复存在</title><link>https://kyon.life/post/philosophy-of-software-design-10/</link><pubDate>Mon, 10 Feb 2020 13:03:59 +0800</pubDate><guid>https://kyon.life/post/philosophy-of-software-design-10/</guid><description>异常处理是软件系统中最糟糕的复杂度来源。处理特殊条件的代码天生比处理正常情况的代码更难编写，而且开发者经常不管异常应该怎样处理就定义了它们。这章讨论了为什么异常对系统复杂度的影响不成比例的大，然后展示了如何简化异常处理。总体来说，本章关键的教训是减少必须处理异常的地方；在许多场景中，可以修改操作的语义，这样正常的操作就可以处理所有情况，因此就没有异常需要上报了（如本章标题）
10.1 为什么异常会增加复杂性 我用 异常 (exception) 这个术语来指代任何改变程序正常流程的特殊情况。许多编程语言都包含一套正式的异常处理机制，允许底层代码抛出异常由封装代码捕获。然而，在不使用正式的异常处理机制时也有可能发生异常，比如当方法返回一个特殊的值，表示它没有完成正常的行为。所有这些形式的异常都会影响到复杂度。
一段特定的代码会以几种不同的方式遇到异常：
调用者可能会提供错误的参数或配置信息 被调用的函数可能无法完成被请求的操作。比如，I/O 可能会失败，或者请求的资源无法使用 在一个分布式系统中，网络数据包可能会丢失或延迟，服务器可能无法及时响应，或对端以一种无法预测的方式进行通信 代码可能会检测到 bug，内部不一致，或者其他它无法处理的情况 大型系统必须处理许多异常情况，尤其是如果它们还是分布式的或者需要容错的话。异常处理可能会占据整个系统代码的一大部分。
异常处理的代码天生比处理正常情况的代码更难编写。异常打断了代码正常的代码执行流程；而且通常意味着某些事情没有按预期进行。当异常发生时，程序可以通过两种方式处理它，每种方式都可能很复杂。第一种方式是不处理异常，继续前进完成进行中的工作。比如，如果出现了网络丢包，可以重新发送；如果数据损坏了，可以从冗余数据中恢复。第二种方式，中止当前的操作并上报异常。然而，中止操作可能会很复杂，因为异常发生时，系统可能处于不一致的状态（数据结构可能只被初始化了一部分）；异常处理代码必须恢复一致性，比如回滚所有异常发生前的改变。
更进一步地，异常处理代码可能会引入更多的异常。考虑重发网络丢包的情况。可能数据包实际上并没有丢，只是简单地延迟了。在这个情景中，重发的数据包会导致重复的数据包到达对端；这就引入了新的对端必须处理的异常情况。或者，考虑从冗余数据中恢复丢失数据的情况：如果冗余数据也丢失了呢？在恢复期间再次发生的异常通常比第一个异常更加微妙和复杂。如果通过中止处理中的操作来处理异常，那么必须作为另外一个异常上报给调用者。为了防止产生无尽的异常链，开发者最终必须找到一种不引入更多异常的方式来处理异常。
支持异常机制的语言通常是繁琐笨拙的，使得异常处理代码更加难以阅读。比如，参考下面的代码，使用 Java 的对象序列化和反序列化从一个文件中读出的推文：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 try ( FileInputStream fileStream = new FileInputStream(fileName); BufferedInputStream bufferedStream = new BufferedInputStream(fileStream); ObjectInputStream objectStream = new ObjectInputStream(bufferedStream); ) { for (int i = 0; i &amp;lt; tweetsPerFile; i++) { tweets.</description></item><item><title>Philosophy of Software Design 第九章 - 合并还是拆分</title><link>https://kyon.life/post/philosophy-of-software-design-9/</link><pubDate>Thu, 06 Feb 2020 10:53:42 +0800</pubDate><guid>https://kyon.life/post/philosophy-of-software-design-9/</guid><description>软件设计中最基本的问题之一是：假定有两个不同的功能，应当在同一个地方实现它们，还是分开实现？这个问题存在于系统的各个层级：函数、方法、类和服务。比如，缓冲应该包含在提供基于流的文件 I/O 服务的类中，还是应该在单独的类中？HTTP 请求解析应该完全在同一个方法中实现，还是应该拆分到多个方法（甚至是多个类中）？这章讨论了做这些决定时需要考虑的因素。其中一些因素在前几章中已经讨论过，但是为了完整性，这里会再说一遍。
当决定应该合并还是拆开时，目标是降低整个系统的复杂度并提高它的模块化程度。看上去最好的办法是，将系统拆分成许多小组件：组件越小，每个组件就可能越简单。然而，过度拆分会增加额外的复杂度：
一些复杂性来自于组件的数量：组件越多，跟踪它们就越困难，而且也更难定位某个组件。过度拆分通常会导致更多的接口，而每一个新接口都会增加复杂度。 过度拆分会需要额外的代码来管理组件。比如，一段代码使用一个对象，在拆分后变为多个，这段代码就不得不由管理单个对象变为管理多个。 过度拆分会创造割裂：过度拆分的组件会远比拆分前更分散。比如，拆分前方法本来在单个类中，拆分后可能会散布在多个类里，还可能会在不同的文件。这种割裂使得开发者难以同时看到整个组件，甚至意识不到它们的存在。如果组件真的独立，那分离开是没问题的：这使得开发者每次专注于一个组件，而不会被其他组件分神。另一方面，如果组件间有依赖，那分离就有问题了：开发者将不得不在组件之间来回跳转。更糟的是，他们可能都意识不到有依赖，从而导致 bug 的产生。 过度拆分可能会导致重复：原来在同一个实例中出现的代码，拆分后就需要出现在每个拆分过的组件中。 最好将将密切关联的不同代码片段组合到。但如果不同片段之间没有关系，它们最好分开。下面是一些两段代码之间有关联的迹象：
它们共享信息；比如，这两段代码都依赖某种特殊类型文档的语法。 它们被同时使用：使用了其中一段代码很有可能也会使用另外一段。只有在这种关系是双向的时候才成立。举一个反例，磁盘缓存几乎总会用到哈希表，但是哈希表可以在很多无关磁盘缓存的场景中使用；因此，这两个模块应当分开。 它们的概念有重合，有一个简单的高层分类包括了这两段代码。比如，查询子串和大小写转换都属于字符串操作范畴；流控制和可靠传输都属于网络通信的范畴。 缺少其中一段代码时，另一段代码就会难以理解。 这章余下部分会用更具体的规则和例子来展示，什么时候将代码段放到一起，什么时候分开它们。
9.1 共享信息时合并 章节 5.4 以一个实现 HTTP 服务器的项目为例介绍了这条原则。在它的第一版实现中，读取和解析 HTTP 请求分别在两个类的两个方法中实现。第一个方法从网络 socket 读取收到的请求文本并把它放到一个 string 对象中。第二个方法解析 string 以获取请求的各个组成部分。使用这种分解方式，两个方法都需要知道大量关于 HTTP 请求格式的知识：第一个方法只是打算读取请求，不解析它，但是只有做了解析需要做的大部分工作才能识别请求体在哪里结束（举例来说，它必须解析请求头所有行才可以识别出包含总的请求体长度的那一行）。由于这种共享的信息，将读取和解析放在同一个地方更好；当把两个类合并成一个时，代码变得更短更简单。
9.2 可以简化接口时合并 当两个或更多个模块合并成一个模块时，为这个新模块定义一个比原来更简单和易用的接口成为可能。当原来的模块实现的是同一个问题的解决方案的不同部分时，这种情况可能会发生。在前一个部分中 HTTP 服务器的例子中，原始的方法的接口需要第一个方法返回 HTTP 请求的 string 并将它传递给第二个方法。当这两个方法合并后，这个接口可以删减掉。
而且，当两个或更多类被合并后，可能可以自动的执行某些功能，这样大多数使用者就不必知道它们的存在。Java 的 I/O 库展示了这种机会。如果 FileInputStream 和 BufferedInputStream 类合并并默认提供缓冲，绝大多数用户甚至不必知道缓冲的存在。合并后的 FileInputStream 类可以提供禁用或替换默认缓冲的机制，但是大多数用户不需要学习这些知识。
9.3 合并以删减重复 如果你发现相同模式的代码一再重复，找一找可以避免重复的代码。一种办法是将重复的代码重构到一个单独的方法中，并将重复代码片段替换为对这个方法的调用。当重复的代码片段很长而且替换方法的签名比较简单时，这种办法是最有效的。如果代码片段只有一两行，用方法调用替换可能带来不了什么收益。如果代码片段和它的上下文环境交互非常复杂（比如会读写大量的本地变量），那么替换方法可能需要一个复杂的签名（比如许多按引用传递的参数），这将降低它的价值。
__图 9.1__：这段代码以几种不同方式处理接收到的网络包；对每一种类型，如果包长度对这种类型来说太短，就会打印一条消息。在这个版本的代码中，`LOG` 语句在几种不同的包类型中重复。
另一种降低重复的办法是，重构代码使得有问题的代码只需要一个地方执行。假设你正在编写一个需要在几个地方返回错误的方法，而每个返回之前都需要执行相同的清理动作（见图 9.1）。如果你使用的编程语言支持 goto，你可以将清理代码放到方法的最后面，然后在每一处需要返回错误时使用 goto 进入。参见图 9.</description></item><item><title>Philosophy of Software Design - 第八章 降低复杂性</title><link>https://kyon.life/post/philosophy-of-software-design-8/</link><pubDate>Mon, 27 Jan 2020 20:27:11 +0800</pubDate><guid>https://kyon.life/post/philosophy-of-software-design-8/</guid><description>这章介绍了另外一种如何设计更有深度的类的考虑方式。假设你正在新建一个模块，然后发现了一处无法避免的复杂实现。下面哪种处理方式更好：应该让模块的使用者处理这个复杂实现吗？还是应该由你在模块内部处理。如果这个复杂实现和模块提供的功能有关，那么通常第二个答案是对的。大多数模块的使用者要多于开发者，所以由开发者受苦要好于使用者受苦。作为模块开发者，你应当尽全力方便使用者，即使那意味着额外的工作量。另外一种表述这个观点的方式是，模块有简单的接口比简单的实现更重要。
作为一个开发者，先实现简单功能，把复杂部分留给其他人的想法非常有诱惑力。如果出现了你不知道该如何处理的状况，最简单的办法就是抛出异常让调用者去处理。如果你不确定实现哪种策略，可以定义一些调整策略的配置参数，并留给系统管理员去找出最好的参数。
像这样的解决办法会让你的生活在短期内更加轻松，但是它们放大了复杂度：许多人都必须处理同一个问题，而不是让同一个人去处理。比如，如果一个类抛出了一个异常，这个类都每个调用者都必须处理它。如果一个类暴露了配置参数，每个系统管理员在每次安装部署时，都需要学习一遍如何配置它们。
8.1 例：文本编辑器类 考虑一下我们第 6、7 章讨论过的文本编辑器类，它为图形化界面的文本编辑器提供管理文本文件的功能。这个类提供了将文件从硬盘读取到内存、查询和修改文件在内存中的副本、将修改后的版本写回硬盘的功能。当学生们要实现这个类时，大多数都会选择面向文本行的接口，并提供读取、插入和删除整行文本的方法。这会得到一个实现简单、但是高层软件调用起来却很复杂的类。在用户接口调用这个级别，操作很少涉及到一整行。比如，按键操作导致单个字符插入到已存在的行中；拷贝或删除选择区域可以修改部分或多行。使用面向文本行的接口时，高层软件在实现用户接口时就不得不对行做拆分合并。
像 6.3 章节中描述的面向字符的接口会将复杂性拉低。用户接口可以插入、删除任意长度的文本，而不需要拆分合并行：这样调用变简单了。文本类的实现可能会变复杂：如果内部使用行的形式来代表文本，那它就需要拆分合并行来实现面向字符的操作。这种实现方法更好，因为它把拆分合并的复杂度封装在了文本类中，这会降低系统总体的复杂度。
8.2 例：配置参数 配置参数是将复杂性上移而不是下移的例子。一个类可以通过暴露一些控制它行为的配置参数，来代替在内部决定一个特定的行为，比如缓存大小或放弃前重试请求的次数。那么，用户就必须为参数指定一个合适的值。现在系统中的配置参数已经变得非常流行；一些系统有上百个参数。
支持者为配置参数的合理性争辩道，它们允许用户根据自己特定的需求和工作负载调整系统。在一些场景中，低层的基础代码很难知道要应用的最好策略，而用户对他们的领域要熟悉的多。比如，用户可能会知道一些请求要比其他请求对时间更敏感，所以让用户为这些请求设置更高的优先级是说得通的。在类似的场景中，配置参数可以在更多的不同领域中获得更好的性能。
然而，配置参数也为逃避处理重要事项并把它们转给其他人处理提供了借口。在许多场景中，用户或管理员很难甚至不可能为参数设置正确值。在另外的场景中，在系统实现时很少的额外工作就可以自动的设置正确的参数值。考虑一个需要处理丢包的网络协议。如果它发送了一个请求，在一定的时间间隔内却没有收到恢复，它就会重新发送请求。决定重试间隔的一种方式是引入一个配置参数。然而，传输协议可以通过自己测量请求成功的回复时间计算出一个合理的值，并使用它的倍数作为重试间隔。这种方式将复杂性拉低，节约了用户找出正确重试时间的力气。它还带来了可以动态计算重试间隔的好处，所以在条件变化时可以自动调整。相反，配置参数很容易过时。
因此，应当尽量避免使用配置参数。在暴露一个配置参数前，问一下自己：“相较于我们自己决定参数值，调用者（或高层模块）可以知道更好的配置吗？”当你创建了配置参数时，看依稀你是否可以自动计算出合理的默认值，这样用户只需要在个别条件下提供配置参数值。理想情况下，每个模块应当完整地解决一个问题；配置参数会使解决方案变得不完整，这将增加系统的复杂度。
8.3 过度实践 当要把复杂性拉低时需要谨慎考虑；这是一个容易过度实践的主意。一个极端的方式会是，将一整个应用的所有的功能都在单个类中实现，这明显是说不通的。拉低复杂性只在以下情况中说得通：(a)复杂性和类中存在的函数有密切关系时 (b) 拉低复杂性可以简化应用中其他许多地方的实现（c）拉低复杂性简化了类的接口。要记住真正的目标是最小化整个系统的复杂度。
第六章描述了一些学生是如何在文本类中定义了会反映用户接口的方法，比如实现了回退健功能的方法。看上去这个实现好像是没问题的，因为它把复杂性拉低了。然而，将用户接口所需了解的知识强加到文本类中并不会大幅简化高层代码，而且用户接口相关的知识和文本类的核心功能关系也不大。在这种情况中，拉低复杂性只导致了信息泄漏。
8.4 结论 当开发一个模块时，应当尽量将调用者的痛苦转移到自己身上。</description></item></channel></rss>