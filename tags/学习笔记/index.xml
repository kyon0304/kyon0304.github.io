<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习笔记 on kyon&#39;s wonderland with ❤️</title>
    <link>https://kyon.life/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 学习笔记 on kyon&#39;s wonderland with ❤️</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Wed, 19 Feb 2020 12:15:39 +0800</lastBuildDate>
    
	<atom:link href="https://kyon.life/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Philosophy of Software Design 第二章 复杂度的天性</title>
      <link>https://kyon.life/post/philosophy-of-software-design-2/</link>
      <pubDate>Wed, 19 Feb 2020 12:15:39 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-2/</guid>
      <description>这本书是关于如何设计软件系统使得它们的复杂度最小化。第一步是了解敌人。到底什么是“复杂性”？你怎么知道一个系统是不必要的复杂？什么会导致系统变复杂？这章会在较高层级解决这些问题；余下的章节会就具体结构特征向你展示如何在较低层级识别复杂度。
识别复杂性是设计技能中一项关键的能力。它使得你可以在投入大量精力前发现问题，并且在许多可选项中做出好选择。分辨出一个设计是否简洁要比创造一个简洁的设计容易，但是一旦你可以识别出一个系统过于复杂，你就可以使用这个能力来指导你的设计哲学向着简单性出发。如果一个设计看上去很复杂，尝试一种不同的方式然后看看是否变简单了。随着时间流逝，你会注意到一些特定的技术会得到更简单的设计，另外一些则和复杂性相关。这将使得你能更快地产出更简洁的设计。
本章也会给出一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节会使用本章的材料来评判各种不同的改善方法和结论。
2.1 定义复杂性 为了这本书的目的，我以一种实践方式定义“复杂性”。复杂性是和软件系统结构相关的、使得理解和修改系统更困难的任何东西。 复杂性可能会以很多形式出现。比如，可能难以理解一段代码是如何运行的；可能一点小的改进需要花费很大精力，或者为了做出改进需要修改系统的哪些部分难以确定；可能很难在不引入其他问题的情况下修复一个 bug。如果很难理解和修改一个软件系统，那么它就是复杂的；如果很容易理解和修改，那它就是简单的。
也可以从成本和收益的角度考虑复杂性。在复杂系统中，哪怕是实现一个很小的改进都需要花费很多工作。在简单系统中，可以用更少的工作完成更大的改进。
复杂性是开发者在尝试完成一个特定目标时在特定时间点的经历。并不一定和系统整体的大小或功能相关。人们经常用“复杂（complex）”一词来描述有着复杂（sophisticated）功能的大型系统，但是如果这样的系统开发很容易上手的话，那么，从本书的角度来看，并不复杂（complex）。当然，几乎所有大型和复杂（sophisticated）的软件系统实际上也难以开发，所以它们也符合我这里复杂的定义。但是这并不一定是事实。小型并不复杂（unsophisticated）的系统也有可能非常复杂（complex）。1
复杂性由最常见的活动决定。如果系统中包括一些非常复杂的部分，但是这些基本不会用到，那它们对系统整体的复杂性几乎没影响。用粗略的数学方式来表示：
$C = ∑c_pt_p$
系统整体复杂性（C）由每部分的复杂性 （$c_p$）加权开发者在这部分花费的时间（$t_p$）决定。把复杂性隔离在一个从不会被看到的地方基本就和完全消除了复杂性一样。
相较于编写者，复杂性对阅读者来说更明显。如果你编写了一段对你来说似乎很简单的代码，但是其他人认为它复杂，那么它就是复杂的。当你发现你处于这样的境况中，请其他开发者来看一下为什么他们觉得代码很复杂就很值得一试；在你和他们不同的观点中很有可能学到有趣的东西。作为开发者的工作不仅仅是写出你觉得容易的代码，也要让其他人觉得容易。
2.2 复杂性的征兆 复杂性通过三种一般的方式表现出来，下面的段落将会描述到。每一种都会使得完成研发任务变得困难。
 图2.1： 网站的每个页面都会展示有颜色的横幅。(a) 中横幅的背景色是在每个页面中显示指定的。(b) 中共享变量保存背景色的值，每个页面都指向这个变量。(c) 中一些页面会展示额外的颜色表示强调，这个颜色是背景色带阴影的较暗的转换；如果背景色变化了，强调色也必须跟着变化。
  放大改变： 复杂性的第一个征兆是，一个看上去简单的改变需要在许多不同的地方修改代码。比如，考虑有着不同页面的网站，每一个页面都会展示有着背景色的横幅。在很多早期网站中，颜色是由每个页面显示地指定的，如图 2.1(a)。为了改变这个网站的背景色，开发者可能需要手动地修改每个已有页面；对于有着上千张页面的大型网站来说这几乎是不可能的。幸运的是，现代的网站使用了图 2.1(b) 中的方式，横幅颜色在一个集中的地方一次性指定，所有页面都指向这个共享的值。使用这种方式时，整个网站的横幅颜色变化可以由单个修改完成。好的设计的目标之一是，减少每个设计决定会影响到的代码数量，这样修改设计时不需要改动很多代码。
心智负担： 复杂性第二个征兆是心智负担，心智负担是指开发者为了完成任务需要了解多少东西。更高的心智负担意味着开发者不得不花费更多时间学习必需了解的信息，而且可能会由于他们遗漏了一些重要信息而增加出现 bug 的风险。比如，C 中分配内存的函数返回指向内存的指针，并且假设调用者会释放内存。这增加了使用这个函数的开发者的心智负担；如果开发者没能释放内存，那么就会出现内存泄漏。如果可以重构系统使得开发者无需关心内存释放（分配内存的模块同时负责释放它），就可以降低心智负担。心智负担以多种方式出现，比如有许多方法的 API，全局变量，不一致性，模块间依赖。
系统设计者有时候认为可以用代码行数衡量复杂性。他们认为如果一个实现比另外的短，那么肯定就更简单；如果只需要很少几行就可以做出改变，那这个改变肯定很容易。然而，这个视角忽略了和心智负担有关的成本。我曾经见过只需要几行就可以完成一个应用的框架，但是想要搞懂这几行做了什么事情却及其困难。有时候需要更多行代码的方式其实更简单，因为它降低了心智负担。
未知的未知： 复杂性的第三个征兆是，为了完成任务需要修改哪些代码或者开发者需要了解哪些信息并不明显。图 2.1(c) 展示了这个问题。网站使用集中变量来决定横幅背景色，所以看上去很容易修改。然而，一些网页使用了带阴影加深的背景色来表示强调，而这个加深的颜色是在每个页面单独指定的。如果背景色变化了，那强调色也必须相匹配地跟着变化。不幸的是，开发者不太可能意识到这个颜色的存在，所以他们可能修改了集中变量 bannerBg 但是没有更新强调色。即使开发者意识到了这个问题，哪些页面使用了强调色也不明显，所以开发者不得不搜索网站中的所有页面。
复杂性的三种表现方式中，未知的未知是最糟糕的。未知的未知意味着你需要了解一些东西，但是你却无法知道需要了解什么，或者甚至这些东西是否存在。在你修改后，直到出现 bug 之前都无法知道。改变放大很烦人，但是只要知道需要修改哪些代码，一旦完成修改系统还是可以工作。类似的，高的心智负担会增加做出改变的成本，但是如果知道哪些信息需要掌握，改变仍旧很可能是正确的。而未知的未知的情况，你将不知道需要做什么，或者提议的方案是否可以工作。唯一可以确定的方式，是阅读系统的每一行代码，这对任何规模的系统都是不切实际的。即使这样也还不够，因为修改可能依赖于一个从未记录的微小的设计决定。
对于系统来说，好设计的最重要的目标之一是使系统变得浅显易懂。这是高心智负担和未知的未知的对立面。在浅显易懂的系统中，开发者可以快速了解已有代码是如何工作的以及做出修改需要什么。浅显易懂的系统中，开发者可以快速的猜出要做什么，不需要非常认真地思考，而且还可以对猜测很有信心。第十八章讨论了使得代码更浅显易懂的技术。
2.3 复杂性的原因 既然你已经知道了复杂性的高层级的征兆，还有为什么复杂性会使得软件开发变困难，下一步就是搞懂什么导致了复杂性，这样我们就可以在设计系统时避免这些问题。复杂性是由两种东西导致的：依赖和模糊。这部分从高层次讨论了这些因素；余下的章节会讨论它们如何与低层次的设计决定相关。
从本书的目的来说，当一段代码无法单独被理解和修改时，就说明存在依赖；这段代码和其他代码以某种方式相关，如果这段代码修改了，也必须考虑和/或修改其他代码。在图 2.1(a) 的网站例子中，背景色创建了所有页面之间的依赖关系。所有页面必须有相同的背景，所以如果一个页面的背景修改了，那么所有其他的页面也必须修改。依赖的另外一个例子出现在网络协议中。一般来说，协议的发送方和接收方代码是独立的，但是它们都必须遵循这个协议；修改发送方的代码几乎总是要求接收方也做出相应修改，反过来也一样。方法的签名创建了这个方法的实现和调用者之间的依赖关系：如果这个方法新增了一个参数，这个方法的所有调用者都必须加以修改来指定这个参数。
依赖是软件中一个基础部分，不能被完全消除。实际上，在软件设计过程中我们会故意引入依赖。你每次新增类的时候，都会创建围绕这个类的 API 的依赖。然而，软件设计的目标之一是减少依赖，并且尽量保持依赖简单和明显。
考虑网站的例子。在每个页面中单独指定背景色的老网站中，所有的网页互相依赖。新网站通过在一个集中的地方指定背景色并提供 API 使得每个页面渲染时可以获取到颜色解决了这个问题。新网站消除了页面之间的依赖，但是创建了围绕获取背景色的 API 的新依赖。幸运的是，新依赖更明显了：每个网页依赖于 bannerBg 是很明显的，开发者可以很容易的找到所有使用这个变量的地方。更进一步的，编译器可以帮助管理 API 依赖：如果共享变量的名字变了，仍然使用原来名字的代码会报编译错误。新的网站用一个更简单更明显的依赖替换了原来不明显、难以管理的依赖。
复杂性的第二个原因是模糊。当重要信息不明显时，模糊就出现了。一个简单的例子是，变量名过于简单，无法携带很多有用信息（比如 时间）。或者，变量的文档可能没有它的单位，所以只能到使用这个变量的地方查看。当依赖的存在不明显时，模糊经常和依赖相关。比如，如果系统中要新增一个错误状态码，可能也需要在存储了每个状态码的文字消息的表中新增一条记录，但是对于看状态定义的程序员来说，消息表的存在可能不够明显。不一致也是模糊的一个重要来源：如果相同的变量名用于两种不同目的，对开发者来说，一个具体的变量服务于哪个目的就不明显了。</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第一章 介绍（一切都与复杂性有关）</title>
      <link>https://kyon.life/post/philosophy-of-software-design-1/</link>
      <pubDate>Wed, 19 Feb 2020 10:16:53 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-1/</guid>
      <description>编写软件是人类历史上最纯粹的创造性活动。程序员不受实践限制的约束，比如物理定律；我们可以创造有着现实世界中不可能存在的行为的令人兴奋的虚拟世界。编写程序不像芭蕾或篮球那样要求有很棒的身体技能或协调性。编写程序所需要的是创造性思维以及组织你的想法的能力。如果你可以想象出一个系统，那么你就有可能在电脑程序中把它实现出来。
这表明编写软件时最大的限制是对我们正在创造的系统的理解能力。随着一个程序不停演进并获得更多功能，它会变得复杂，组件之间会有不起眼的依赖。时间流逝，复杂度会累积，程序员在修改系统时，越来越难以把所有相关的因素都记在脑子里。这就会拖慢研发速度，并且导致 bug 产生，然后形成一个恶性循环。任何程序的复杂度都会不可避免的变高。越大型的程序，越多的人参与开发，就越难以控制复杂度。
好的开发工具可以帮助我们处理复杂度，过去的几十年中有许多很厉害的工具被创造了出来。但是仅仅使用这些工具，我们能做到的事情是有限制的。如果我们想要把编写软件变得简单，使得构建强大的系统变得更容易，我们必须找到使软件更简单的方式。尽管我们尽了最大的努力，复杂度还是会随着时间增长，但是更简单的设计允许我们在复杂度不可控之前构建出更大型更强大的系统。
控制复杂度有两种通用的方式，这本书都会讨论。第一种方式使通过使代码更简单更清晰来消除复杂度。比如，通过去除特殊场景或使用一致的标识可以减少复杂性。
第二种方式是封装复杂性，这样程序员可以在不完全了解它的复杂性的情况下基于这个系统进行开发。这种方式被称作 模块化设计。在模块化设计中，一个软件系统划分为不同的模块，比如面向对象语言中的类。模块被设计为相对独立的，这样程序员可以在不了解其他模块细节的情况下开发当前模块。
由于软件是如此具有延展性，所以软件设计是一个会横跨整个软件系统生命周期的持续的过程；这使得软件设计不同于物理系统比如建筑、轮船或桥梁的设计。然而，软件设计并不是一致被这样看待的。对于编程的历史上大多数时候，设计都集中于项目的开始阶段，就像其他工程原则一样。这种方式的极端被称为 瀑布模型，项目被划分为分散的阶段比如需求定义、设计、开发、测试和维护。在瀑布模型中，每个阶段都在下一个阶段开始前结束；大多数情况下，每个阶段是由不同的人来负责。整个系统在设计阶段一次性设计完成。这个阶段结束时设计就固定了，余下的阶段只是充实和设计这个设计。
不幸的是，瀑布模型对软件来说几乎无法奏效。软件系统本质上要比物理系统更复杂；对于大型软件系统来说，在没有搭建任何东西之前，不可能将设计考虑地足够全面。结果，最初的设计会有许多问题。在进行实现之前这些问题都不会明显地暴露出来。然而，这时瀑布模型无法应对重大设计的变更（比如，设计者已经调去其他项目）。因此，程序员会尝试在不改变整体设计的情况下修补问题。这会导致复杂度爆炸性增长。
由于这些问题的存在，当今的大多数软件开发项目采用一种增量的方式，比如 敏捷开发，最初的设计只关注总体功能的一小部分。这一部分被设计、实现，然后被评估。发现并更正原来设计中的问题，然后设计、实现和评估更多的功能。每次迭代都会暴露已有设计中的问题，并在设计下一部分的功能前修复。通过以这样的方式将设计扩散出去，最初设计中的问题可以在系统仍旧比较小型时修复；后面的功能可以从早期功能开发的经验中获益，所以出的问题会变少。
增量的方式对软件奏效是因为软件具有足够的延展性，允许在实现的过程中出现重大的设计变更。相反，对物理系统来说，重大的设计变更会更具有挑战性：比如，在建造过程中修改桥墩的数量是不切实际的。
增量研发意味着软件设计永远未完成。在系统的生命中设计持续存在：开发者应该一直考虑设计问题。增量研发也意味着持续的重新设计。系统或组件的初始设计几乎从来不是最好的；经验会不可避免地展示出完成这件事情的更好方式。作为一名软件开发者，应该始终寻找提升你正在开发的系统的设计的机会，而且应该为设计改进预留出一部分时间。
如果软件开发者应该使用考虑设计问题，并且降低复杂性是软件设计最重要的元素，那么软件开发者应该始终考虑复杂性。这本书就是关于如何使用复杂性指导软件设计的。
这本书有两个整体目标。第一个是描述软件复杂性的天性：“复杂性”意味着什么，为什么重要，以及如何识别出程序中存在不必要的复杂性？这本书第二个，而且更具挑战性的目标是给出在软件开发期间可以用来最小化复杂性的技术。不幸的是，并没有能够保证很棒的软件设计的简单的处方。相反，我会给出一系列哲学化的高层的概念，比如“类应该有深度” 或者 “通过定义使得错误不复存在”。这些概念可能无法立即区分出最好的设计，但是你可以使用它们比较不同的设计选择，并指导你在设计领域的探索。
1.1 如何使用这本书 这里讨论的设计原则很多都在一定程度上抽象，所以不看实际的代码可能会很难理解。寻找既足够小到可以放到书中又足够大到可以展示问题的例子非常困难（如果你遇到了好例子，请把它们发送给我）。所以，学习如何应用这些原则，只看这本书可能不够。
使用这本书最好的方式是和代码审查联合起来。当你阅读别人的代码时，考虑它是否遵循了这里讨论的概念，以及如何影响代码的复杂度。在别人的代码中更容易看到设计问题。你可以用本书中描述的红色警告来识别问题并且提出改进建议。审查代码也会使你接触到新的设计方式以及编程技巧。
提升你的设计技能的最好的方式之一是学习识别 红色警告：一段代码可能比它实际需要的更复杂的信号。在本书的课程中，我会指出和每个主要设计问题相关的表示问题出现的红色警告；最重要的几个在书的最后做了总结。当你编码时可以使用：当你看到一个红色警告，停止工作并寻找可以消除问题的其他设计。当你第一次尝试这种方式时，在找到可以消除红色警告的设计前，可能不得不尝试好几种设计。不要轻易放弃：在修复问题前尝试地越多，你学到的越多。随着时间流逝，你会发现代码中的红色警告越来越少，你的设计变得越来越简洁。你的经验也会向你展示其他红色警告，你可以用来识别设计问题（我会很乐意听到你新发现的这些红色警告）。
当应用本书中的理念时，应当注意节制和谨慎。每条规则都有例外，每个规范都有限制。如果你把每个设计理念都发挥到极致，可能最终会陷入困境。漂亮的设计反应了理念和实现之间较量的平衡。有几个章节中包含名为“过度实践”的部分，描述了如何发现你已经过度了。
这本书几乎所有例子都是 Java 或 C++ 的，大多数讨论都是针对面向对象语言中的设计类。然而，这些理念也可以很好的应用于其他领域。几乎所有和方法有关的理念也可以应用于没有面向对象功能的语言中的函数，比如 C。设计理念也可以应用于模块而不是类，比如子系统或网络服务。
有了这些基础以后，让我们更细致地讨论是什么导致了复杂性，以及如何使软件系统更简单。</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第十一章 设计两次</title>
      <link>https://kyon.life/post/philosophy-of-software-design-11/</link>
      <pubDate>Fri, 14 Feb 2020 10:47:48 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-11/</guid>
      <description>设计软件是很难的，所以当你考虑如何构建一个模块或系统时，不太可能第一个想法就会产生最好的设计。如果对每个主要的设计决定都多考虑几个选项，会得到一个好得多的结果：设计两次。
假设你正在设计图形化文本编辑器中管理文本的类。第一步是定义这个类由编辑器中其他部分使用的的接口；与其使用第一个蹦到脑子里的主意，不如多考虑几种可能性。其中一个选择是面向行的接口，插入、修改和删除整行的文本。另外一个选择是基于单个字符的插入和删除接口。第三个选择是面向字符串的接口，对可能跨越行边界的任意范围的字符进行操作。不需要把每个选项的所有功能特性都确定下来；到目前为止，把几个重要的方法大概轮廓勾勒出来就足够了。
尝试选择和其他几种有本质区别的方式；这样你可以学到更多。即使你很确定只有一种合理的方式，也要考虑一下第二种设计方式，不管你认为它会有多糟糕。思考那个设计的弱点并且把它和其他设计的功能做对比是很有启发性的。
当你粗略地描绘出几种不同的设计后，列一个每个设计的优缺点的表格。最重要的考量是，这个接口对高层的软件来说是否易用。在上面的例子中，面向行和面向字符的接口都需要使用文本类的接口做额外的工作。使用面向行的接口时，当遇到部分或跨行的操作比如剪切和复制选区时，高层的软件需要拆分和合并行。使用面向字符的接口时，对于需要修改多个字符的操作需要循环实现。另外也需要考虑如下几种因素：
 其中一种选择比其他有着更简单的接口吗？在文本类的例子中，所有的文本接口都差不多简单。 其中一个接口比其他更通用吗？ 使用其中一个接口的实现会比其他更高效吗？在文本类的例子中，面向字符的接口很可能会比起另外的慢很多，因为它要求每一个字符都调用文本类一次  当你比较过几种不同的设计以后，你将可以更好地确定最佳设计。最好的选择可能是可选项中的一种，或者你可能发现可以把多个选项的功能组合成一个新的设计，会比原来的选择更好。
有时每个选择都不太好；当这种情况发生时，考虑一下能不能想到另外的方案。用你在原有选择中发现的问题来驱动新的设计。如果你正在设计文本类并且只想到了面向行和面向字符的这两种设计方式，你可能会注意到，这两种方式用起来都很别扭，因为它们要求高层软件做额外的文本操作。这是一个红色警告：如果需要有一个文本类，那么它应该处理所有和文本相关的操作。为了消除额外的文本操作，文本接口应该和高层软件中的操作更匹配。这些操作并不总是对应到单个字符或单行。这条推理应该引导你得到一个面向范围的 API，这会消除之前设计中的问题。
设计两次的原则可以应用在系统中的许多层级。对于模块来说，你可以先用这个原则来选择接口，像上面描述的那样。然后当你设计实现时可以再次应用这个原则：对于文本类来说，你可能考虑过各种实现比如行的链表，固定长度的字符块，或者“gap buffer”。设计实现时的目标和设计接口时并不一样：对于实现来说，最重要的是简洁和性能。在设计系统的高层时多探索几种可能性也是很有用的，比如当选择用户界面的功能时，或者将系统拆解为主要模块时。在每个例子中，如果能够比较几个不同的选择就可以更容易发现最好的方案。
设计两遍并不需要占用非常多额外的时间。对于一个小模块比如类来说，你可能都用不到一两个小时来考虑可选项。相比于在实现类时你需要花去好几天甚至好几个星期，这是非常少的时间了。最开始的设计实验很可能最终会有助于得到一个更好的设计，收益会远大于在设计两遍时花费的时间。对于更大的模块，最开始的设计探索会花费更多的时间，但是实现也会更慢，而且更好的设计的收益也会更高。
我注意到设计两遍的原则有时候对非常聪明的人来说很难接受。当他们成长时，聪明人发现他们关于任何问题的第一个快速的想法都足够好；没有必要再考虑第二种或者第三种可能。这就培养了一种糟糕的工作习惯。然而，当这些人更年长一些，他们不断提升进入有着越来越难的问题的环境中。最终，每个人都会到达第一个想法不够好的地步；如果你想要获得真正厉害的结果，就必须考虑第二种可能，或者可能是第三种，不管你有多聪明。大型软件系统的设计就属于这个分类：没有人可以第一次尝试就把它做对。
不幸的是，我经常看到坚持实现第一个想法的聪明人，这导致他们无法发挥真正的潜能（同时也使得和他们共事令人沮丧）。或许他们下意识地认为“聪明人可以第一次就做对”，所以如果他们尝试不同地设计就会表明他们其实并不聪明。不是这样的。不是你不聪明；而是问题真的很难！而且，这是一件好事：相比完全不用动脑的简单问题，解决需要仔细思考的难题要有趣得多。
设计两遍的方式不仅提高了你的设计，而且可以提高你设计的技能。设计和比较不同方式的过程会教给你影响设计好坏的因素。随着时间的推移，排除糟糕的设计并磨练真正厉害的设计对你来说会越来越容易。</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第十章 通过定义使得错误不复存在</title>
      <link>https://kyon.life/post/philosophy-of-software-design-10/</link>
      <pubDate>Mon, 10 Feb 2020 13:03:59 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-10/</guid>
      <description>异常处理是软件系统中最糟糕的复杂度来源。处理特殊条件的代码天生比处理正常情况的代码更难编写，而且开发者经常不管异常应该怎样处理就定义了它们。这章讨论了为什么异常对系统复杂度的影响不成比例的大，然后展示了如何简化异常处理。总体来说，本章关键的教训是减少必须处理异常的地方；在许多场景中，可以修改操作的语义，这样正常的操作就可以处理所有情况，因此就没有异常需要上报了（如本章标题）
10.1 为什么异常会增加复杂性 我用 异常 (exception) 这个术语来指代任何改变程序正常流程的特殊情况。许多编程语言都包含一套正式的异常处理机制，允许底层代码抛出异常由封装代码捕获。然而，在不使用正式的异常处理机制时也有可能发生异常，比如当方法返回一个特殊的值，表示它没有完成正常的行为。所有这些形式的异常都会影响到复杂度。
一段特定的代码会以几种不同的方式遇到异常：
 调用者可能会提供错误的参数或配置信息 被调用的函数可能无法完成被请求的操作。比如，I/O 可能会失败，或者请求的资源无法使用 在一个分布式系统中，网络数据包可能会丢失或延迟，服务器可能无法及时响应，或对端以一种无法预测的方式进行通信 代码可能会检测到 bug，内部不一致，或者其他它无法处理的情况  大型系统必须处理许多异常情况，尤其是如果它们还是分布式的或者需要容错的话。异常处理可能会占据整个系统代码的一大部分。
异常处理的代码天生比处理正常情况的代码更难编写。异常打断了代码正常的代码执行流程；而且通常意味着某些事情没有按预期进行。当异常发生时，程序可以通过两种方式处理它，每种方式都可能很复杂。第一种方式是不处理异常，继续前进完成进行中的工作。比如，如果出现了网络丢包，可以重新发送；如果数据损坏了，可以从冗余数据中恢复。第二种方式，中止当前的操作并上报异常。然而，中止操作可能会很复杂，因为异常发生时，系统可能处于不一致的状态（数据结构可能只被初始化了一部分）；异常处理代码必须恢复一致性，比如回滚所有异常发生前的改变。
更进一步地，异常处理代码可能会引入更多的异常。考虑重发网络丢包的情况。可能数据包实际上并没有丢，只是简单地延迟了。在这个情景中，重发的数据包会导致重复的数据包到达对端；这就引入了新的对端必须处理的异常情况。或者，考虑从冗余数据中恢复丢失数据的情况：如果冗余数据也丢失了呢？在恢复期间再次发生的异常通常比第一个异常更加微妙和复杂。如果通过中止处理中的操作来处理异常，那么必须作为另外一个异常上报给调用者。为了防止产生无尽的异常链，开发者最终必须找到一种不引入更多异常的方式来处理异常。
支持异常机制的语言通常是繁琐笨拙的，使得异常处理代码更加难以阅读。比如，参考下面的代码，使用 Java 的对象序列化和反序列化从一个文件中读出的推文：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  try (FileInputStream fileStream =new FileInputStream(fileName);BufferedInputStream bufferedStream =new BufferedInputStream(fileStream);ObjectInputStream objectStream =new ObjectInputStream(bufferedStream);) {for (int i = 0; i &amp;lt; tweetsPerFile; i++) {tweets.</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第九章 - 合并还是拆分</title>
      <link>https://kyon.life/post/philosophy-of-software-design-9/</link>
      <pubDate>Thu, 06 Feb 2020 10:53:42 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-9/</guid>
      <description>软件设计中最基本的问题之一是：假定有两个不同的功能，应当在同一个地方实现它们，还是分开实现？这个问题存在于系统的各个层级：函数、方法、类和服务。比如，缓冲应该包含在提供基于流的文件 I/O 服务的类中，还是应该在单独的类中？HTTP 请求解析应该完全在同一个方法中实现，还是应该拆分到多个方法（甚至是多个类中）？这章讨论了做这些决定时需要考虑的因素。其中一些因素在前几章中已经讨论过，但是为了完整性，这里会再说一遍。
当决定应该合并还是拆开时，目标是降低整个系统的复杂度并提高它的模块化程度。看上去最好的办法是，将系统拆分成许多小组件：组件越小，每个组件就可能越简单。然而，过度拆分会增加额外的复杂度：
 一些复杂性来自于组件的数量：组件越多，跟踪它们就越困难，而且也更难定位某个组件。过度拆分通常会导致更多的接口，而每一个新接口都会增加复杂度。 过度拆分会需要额外的代码来管理组件。比如，一段代码使用一个对象，在拆分后变为多个，这段代码就不得不由管理单个对象变为管理多个。 过度拆分会创造割裂：过度拆分的组件会远比拆分前更分散。比如，拆分前方法本来在单个类中，拆分后可能会散布在多个类里，还可能会在不同的文件。这种割裂使得开发者难以同时看到整个组件，甚至意识不到它们的存在。如果组件真的独立，那分离开是没问题的：这使得开发者每次专注于一个组件，而不会被其他组件分神。另一方面，如果组件间有依赖，那分离就有问题了：开发者将不得不在组件之间来回跳转。更糟的是，他们可能都意识不到有依赖，从而导致 bug 的产生。 过度拆分可能会导致重复：原来在同一个实例中出现的代码，拆分后就需要出现在每个拆分过的组件中。  最好将将密切关联的不同代码片段组合到。但如果不同片段之间没有关系，它们最好分开。下面是一些两段代码之间有关联的迹象：
 它们共享信息；比如，这两段代码都依赖某种特殊类型文档的语法。 它们被同时使用：使用了其中一段代码很有可能也会使用另外一段。只有在这种关系是双向的时候才成立。举一个反例，磁盘缓存几乎总会用到哈希表，但是哈希表可以在很多无关磁盘缓存的场景中使用；因此，这两个模块应当分开。 它们的概念有重合，有一个简单的高层分类包括了这两段代码。比如，查询子串和大小写转换都属于字符串操作范畴；流控制和可靠传输都属于网络通信的范畴。 缺少其中一段代码时，另一段代码就会难以理解。  这章余下部分会用更具体的规则和例子来展示，什么时候将代码段放到一起，什么时候分开它们。
9.1 共享信息时合并 章节 5.4 以一个实现 HTTP 服务器的项目为例介绍了这条原则。在它的第一版实现中，读取和解析 HTTP 请求分别在两个类的两个方法中实现。第一个方法从网络 socket 读取收到的请求文本并把它放到一个 string 对象中。第二个方法解析 string 以获取请求的各个组成部分。使用这种分解方式，两个方法都需要知道大量关于 HTTP 请求格式的知识：第一个方法只是打算读取请求，不解析它，但是只有做了解析需要做的大部分工作才能识别请求体在哪里结束（举例来说，它必须解析请求头所有行才可以识别出包含总的请求体长度的那一行）。由于这种共享的信息，将读取和解析放在同一个地方更好；当把两个类合并成一个时，代码变得更短更简单。
9.2 可以简化接口时合并 当两个或更多个模块合并成一个模块时，为这个新模块定义一个比原来更简单和易用的接口成为可能。当原来的模块实现的是同一个问题的解决方案的不同部分时，这种情况可能会发生。在前一个部分中 HTTP 服务器的例子中，原始的方法的接口需要第一个方法返回 HTTP 请求的 string 并将它传递给第二个方法。当这两个方法合并后，这个接口可以删减掉。
而且，当两个或更多类被合并后，可能可以自动的执行某些功能，这样大多数使用者就不必知道它们的存在。Java 的 I/O 库展示了这种机会。如果 FileInputStream 和 BufferedInputStream 类合并并默认提供缓冲，绝大多数用户甚至不必知道缓冲的存在。合并后的 FileInputStream 类可以提供禁用或替换默认缓冲的机制，但是大多数用户不需要学习这些知识。
9.3 合并以删减重复 如果你发现相同模式的代码一再重复，找一找可以避免重复的代码。一种办法是将重复的代码重构到一个单独的方法中，并将重复代码片段替换为对这个方法的调用。当重复的代码片段很长而且替换方法的签名比较简单时，这种办法是最有效的。如果代码片段只有一两行，用方法调用替换可能带来不了什么收益。如果代码片段和它的上下文环境交互非常复杂（比如会读写大量的本地变量），那么替换方法可能需要一个复杂的签名（比如许多按引用传递的参数），这将降低它的价值。
  图 9.1：这段代码以几种不同方式处理接收到的网络包；对每一种类型，如果包长度对这种类型来说太短，就会打印一条消息。在这个版本的代码中，LOG 语句在几种不同的包类型中重复。
  另一种降低重复的办法是，重构代码使得有问题的代码只需要一个地方执行。假设你正在编写一个需要在几个地方返回错误的方法，而每个返回之前都需要执行相同的清理动作（见图 9.1）。如果你使用的编程语言支持 goto，你可以将清理代码放到方法的最后面，然后在每一处需要返回错误时使用 goto 进入。参见图 9.</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design - 第八章 降低复杂性</title>
      <link>https://kyon.life/post/philosophy-of-software-design-8/</link>
      <pubDate>Mon, 27 Jan 2020 20:27:11 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-8/</guid>
      <description>这章介绍了另外一种如何设计更有深度的类的考虑方式。假设你正在新建一个模块，然后发现了一处无法避免的复杂实现。下面哪种处理方式更好：应该让模块的使用者处理这个复杂实现吗？还是应该由你在模块内部处理。如果这个复杂实现和模块提供的功能有关，那么通常第二个答案是对的。大多数模块的使用者要多于开发者，所以由开发者受苦要好于使用者受苦。作为模块开发者，你应当尽全力方便使用者，即使那意味着额外的工作量。另外一种表述这个观点的方式是，模块有简单的接口比简单的实现更重要。
作为一个开发者，先实现简单功能，把复杂部分留给其他人的想法非常有诱惑力。如果出现了你不知道该如何处理的状况，最简单的办法就是抛出异常让调用者去处理。如果你不确定实现哪种策略，可以定义一些调整策略的配置参数，并留给系统管理员去找出最好的参数。
像这样的解决办法会让你的生活在短期内更加轻松，但是它们放大了复杂度：许多人都必须处理同一个问题，而不是让同一个人去处理。比如，如果一个类抛出了一个异常，这个类都每个调用者都必须处理它。如果一个类暴露了配置参数，每个系统管理员在每次安装部署时，都需要学习一遍如何配置它们。
8.1 例：文本编辑器类 考虑一下我们第 6、7 章讨论过的文本编辑器类，它为图形化界面的文本编辑器提供管理文本文件的功能。这个类提供了将文件从硬盘读取到内存、查询和修改文件在内存中的副本、将修改后的版本写回硬盘的功能。当学生们要实现这个类时，大多数都会选择面向文本行的接口，并提供读取、插入和删除整行文本的方法。这会得到一个实现简单、但是高层软件调用起来却很复杂的类。在用户接口调用这个级别，操作很少涉及到一整行。比如，按键操作导致单个字符插入到已存在的行中；拷贝或删除选择区域可以修改部分或多行。使用面向文本行的接口时，高层软件在实现用户接口时就不得不对行做拆分合并。
像 6.3 章节中描述的面向字符的接口会将复杂性拉低。用户接口可以插入、删除任意长度的文本，而不需要拆分合并行：这样调用变简单了。文本类的实现可能会变复杂：如果内部使用行的形式来代表文本，那它就需要拆分合并行来实现面向字符的操作。这种实现方法更好，因为它把拆分合并的复杂度封装在了文本类中，这会降低系统总体的复杂度。
8.2 例：配置参数 配置参数是将复杂性上移而不是下移的例子。一个类可以通过暴露一些控制它行为的配置参数，来代替在内部决定一个特定的行为，比如缓存大小或放弃前重试请求的次数。那么，用户就必须为参数指定一个合适的值。现在系统中的配置参数已经变得非常流行；一些系统有上百个参数。
支持者为配置参数的合理性争辩道，它们允许用户根据自己特定的需求和工作负载调整系统。在一些场景中，低层的基础代码很难知道要应用的最好策略，而用户对他们的领域要熟悉的多。比如，用户可能会知道一些请求要比其他请求对时间更敏感，所以让用户为这些请求设置更高的优先级是说得通的。在类似的场景中，配置参数可以在更多的不同领域中获得更好的性能。
然而，配置参数也为逃避处理重要事项并把它们转给其他人处理提供了借口。在许多场景中，用户或管理员很难甚至不可能为参数设置正确值。在另外的场景中，在系统实现时很少的额外工作就可以自动的设置正确的参数值。考虑一个需要处理丢包的网络协议。如果它发送了一个请求，在一定的时间间隔内却没有收到恢复，它就会重新发送请求。决定重试间隔的一种方式是引入一个配置参数。然而，传输协议可以通过自己测量请求成功的回复时间计算出一个合理的值，并使用它的倍数作为重试间隔。这种方式将复杂性拉低，节约了用户找出正确重试时间的力气。它还带来了可以动态计算重试间隔的好处，所以在条件变化时可以自动调整。相反，配置参数很容易过时。
因此，应当尽量避免使用配置参数。在暴露一个配置参数前，问一下自己：“相较于我们自己决定参数值，调用者（或高层模块）可以知道更好的配置吗？”当你创建了配置参数时，看依稀你是否可以自动计算出合理的默认值，这样用户只需要在个别条件下提供配置参数值。理想情况下，每个模块应当完整地解决一个问题；配置参数会使解决方案变得不完整，这将增加系统的复杂度。
8.3 过度实践 当要把复杂性拉低时需要谨慎考虑；这是一个容易过度实践的主意。一个极端的方式会是，将一整个应用的所有的功能都在单个类中实现，这明显是说不通的。拉低复杂性只在以下情况中说得通：(a)复杂性和类中存在的函数有密切关系时 (b) 拉低复杂性可以简化应用中其他许多地方的实现（c）拉低复杂性简化了类的接口。要记住真正的目标是最小化整个系统的复杂度。
第六章描述了一些学生是如何在文本类中定义了会反映用户接口的方法，比如实现了回退健功能的方法。看上去这个实现好像是没问题的，因为它把复杂性拉低了。然而，将用户接口所需了解的知识强加到文本类中并不会大幅简化高层代码，而且用户接口相关的知识和文本类的核心功能关系也不大。在这种情况中，拉低复杂性只导致了信息泄漏。
8.4 结论 当开发一个模块时，应当尽量将调用者的痛苦转移到自己身上。</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design - 第七章 不同层，不同抽象</title>
      <link>https://kyon.life/post/philosophy-of-software-design/</link>
      <pubDate>Thu, 23 Jan 2020 16:37:33 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design/</guid>
      <description>软件系统是由不同层构成的，高层使用底层提供的功能。在一个设计良好的系统中，每一层都提供有别于其他层的抽象，如果你触发一个函数调用并跟踪它在不同层中的操作，就会发现每一层的抽象都会发生变化。比如：
 在文件系统中，最上层实现了文件抽象。一个文件包含一个可变长的比特数组，并且支持不定长的读写更新。文件系统中低一层的抽象实现了固定大小硬盘块的内存缓存；调用者可以假设频繁使用的块会驻留在内存中以供快速获取。最底层是硬件驱动，负责在二级存储设备和内存之间搬运数据块。 在网络传输协议比如 TCP 中，最上层提供的抽象是机器之间可信赖的比特流传输。这是建立在低一层的尽力而为传输服务之上的：大部分数据包都可以成功送达，但是部分包会丢失或者乱序。  7.1 Pass-through 方法 当相邻的层具有相仿的抽象时，问题会以 pass-through 方法的方式表现出来。pass-through 方法的签名和它调用的方法一样或类似，除了调用其他方法基本没有实现别的功能。比如，一个学生项目实现的文本编辑界面中有个类基本都是 pass-through 方法。下面是这个类的摘要：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class TextDocument ... {private TextArea textArea;private TextDocumentListener listener;...public Character getLastTypedCharacter() {return textArea.getLastTypedCharacter();}public int getCursorOffset() {return textArea.getCursorOffset();}public void insertString(String textToInsert, int offset) {textArea.</description>
    </item>
    
    <item>
      <title>HTTP/3 的过去、现在及将来</title>
      <link>https://kyon.life/post/http3/</link>
      <pubDate>Mon, 06 Jan 2020 10:13:03 +0800</pubDate>
      
      <guid>https://kyon.life/post/http3/</guid>
      <description>看了一篇 cloudflare 讲 http/3 的文章，http/3 on quic，底层都不再依赖 tcp 协议了而是用 quic 协议。
以下是三代 http 协议的对比，使用中遇到的问题以及解决方案。
http/1 每个 tcp 连接只能承载一个 http 请求，而建立 tcp 的代价很高，三次握手、拥塞控制、加密协议握手，这就导致 http 通信成本很高。
http/1.1 通过 connection:keep-alive 多个请求复用同一个 tcp 连接，可以将握手及慢启动耗费的时间平摊到多个请求中，但问题是，一个 tcp 连接中的多个 http 请求是串行的，所以对每个连接来说，客户端和服务端依旧只能处理单个请求，而现代的网站通常会并行的向同一个服务器请求多个文件，css、js 等，于是需要建立多个 tcp 连接，问题回到 http/1。
http/2 解决方案是可以在一个 tcp 连接中可以并行传输多个 http 请求，但是依然存在的问题是，tcp 的责任是以正确的顺序传输数据，出现丢包时，tcp 协议会进行重发，由于 tcp 对承载的 http 请求是没有解析的，这时丢包数据后面的字节就无法被正常发送到客户端，即使他们本身并没有丢失数据而且和丢包所包含的数据是独立的 http 请求。最终结果是，这些请求被无意义地延迟，因为 tcp 协议无法得知丢包会不会对客户端的数据重建产生影响，这被称作 head-of-line blocking。
http/3 on quic 就是为了解决这个问题而诞生，它依赖的传输层协议不再 tcp 协议而是 quic，quic 将 stream 当作一等公民对待，quic streams 共享一个连接，因此减少了额外的握手和慢启动所使用的时间。http/3 可以简单的将 http 请求映射到 quic 的 stream 上。quic 的 stream 是独立传输的，所以在大多数丢包的场景中，只会影响一个 stream 而不会产生连锁效应，这可能是 quic 协议是基于 udp 报文的缘故。而专门再设计一个 http3 协议而不复用之前的 http2，是因为 http2 的 header 中的压缩 scheme HPACK 设计上，会严重依赖 http 请求的顺序，这是 quic 协议传输中所不能满足的，quic 只能保证单个 stream 中的字节是有序的，而不同 stream 的到达顺序则不保证。这就导致需要重新设计 http 协议中的 header 压缩 scheme，新的叫做 QPACK。而且一些 http/2 协议中的功能比如 per-stream 流控制已经由 quic 协议所实现，http/3 就将这些功能去掉了，减少协议中无意义的复杂度。使用 udp 协议还有一个好处是， quic 协议完全可以在用户空间实现，不再像 tcp 那样与操作系统绑定，这就给了 quic 协议实现极大的自由度。</description>
    </item>
    
    <item>
      <title>Threadlocal 梳理</title>
      <link>https://kyon.life/post/threadlocal/</link>
      <pubDate>Sun, 22 Dec 2019 18:24:10 +0800</pubDate>
      
      <guid>https://kyon.life/post/threadlocal/</guid>
      <description>使用场景 用于同一线程中，不同类、不同方法间数据共享。没有 ThreadLocal 的帮助，这些需要共享的数据，就必须通过参数、返回值进行传递，将会变得非常繁琐。常见的使用场景，比如存储登录用户信息，同一个 request 的 trace id 等。
实现 ThreadLocalMap 是 ThreadLocal 的静态内部类，Entry 是 ThreadLocalMap 的静态内部类，其中 Entry 是弱引用的子类，referent 指向 threadlocal 对象，value 成员变量则是真正存储用户设置的值的地方。
如何存储 首先，用一张图来表示一下 threadlocal 是如何存储数据的：
可以看到，用户关心的数据存储在 ThreadLocal 内部静态类 Entry 的 value 成员变量中，Entry 类型的变量有多个，组成数组 table，由 ThreadLocalMap 的实例所持有，而 ThreadLocalMap 实例则是线程的成员变量 threadlocals。因此，当多线程环境下访问同一个类实例的 ThreadLocal 变量时，其实每个线程都有各自的 ThreadLocalMap 变量 threadlocals，从而持有各自的 Entry 及其 value。这就是 ThreadLocal 如何做到线程安全的，不同线程使用的是不同副本。
ThreadLocalMap 内部维护了一个 Entry[] 类型的数组变量 table，索引 Entry 的实例时，有两种方式，一种是通过 hashcode 计算快速定位，另外一种是快速定位失效时，使用 threadlocal 实例循环比对 entry 的 referant。
ThreadLocal, ThreadLocalMap, Entry 三者的套娃定义如下：
1 2 3 4 5 6 7 8 9 10 11 12 13  public class ThreadLocal&amp;lt;T&amp;gt; { static class ThreadLocalMap {static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?</description>
    </item>
    
    <item>
      <title>《架构整洁之道》读后</title>
      <link>https://kyon.life/post/clean-architecture/</link>
      <pubDate>Sun, 13 Jan 2019 15:29:17 +0800</pubDate>
      
      <guid>https://kyon.life/post/clean-architecture/</guid>
      <description>4/5 星推荐
用了大概一周多的时间看完了，一本简明的工具书，从不同的编程范式说起，指出了构建软件时应当遵循的规则，以及为什么应当遵循。这篇是在看完合住书的情况下按照回忆来写的，写着写着就断掉了，苦不堪言，还是要时不时的回去看书啊。
相对于硬件，软件应当「柔软」，不与运行平台绑定，对新需求友好。
编程范式有三种，面向过程编程，面向对象编程，函数式编程。这三种范式都是通过约束程序员的能力，换取程序的健壮性。面向过程编程约束了 goto 语句，不允许程序执行流程随意跳转，将函数的控制语句限制在 if...else.., for..loop 这几种，保证了程序的可推导性；面向对象编程约束了函数指针的使用，多态取而代之，使得依赖反转以及插件式设计更加容易；函数式编程约束了变量的可变性，即在函数式编程思想中，变量一旦赋值是不可更改的，从而在根源上避免了各种多线程并发问题。
编程范式在源码层面保证了整洁，而架构设计也需要整洁。
开发系统时，划分组件应当遵循的 SOLID 原则：
 SRP 单一职责原则，同一个组件的代码实现的功能应当同属一个职责，同时也应当兼顾变更速度，否则会导致一个小的改动引起其他功能的错误或者至少是更多的回归测试 OCP 开闭原则，对扩展友好，对修改拒绝。开发组件时应当考虑如何设计才能够使得以后引入新功能时，可以通过扩展实现，而尽量降低修改对原有代码的影响。一种模式是支持插件式设计。另外的考虑是，对依赖方向的控制。一般来说频繁的需求变更都不会影响核心业务逻辑，因此将核心业务逻辑放在依赖方向的最上层，依赖只会从下往上，以此下推，新需求只会影响下层的模块，而不需要大规模修改核心逻辑部分。 LSP 里氏替换原则，继承实现的指导原则，在可以使用父类的地方，使用子类替换后，行为不能异常。 ISP 接口隔离原则，通过接口隔离依赖，可以减少很多不必要的麻烦。 DIP 依赖反转原则，控制流的依赖应当遵循依赖守则：单向的、由下层指向上层。而源码依赖和控制流依赖的方向通常是相反的。  划分组件时，我们一般会想到 MVC，model、view、controller，这是按照流程功能来做的归类，与特定系统处理的领域无关，即不管是哪个领域的软件系统，都可以按照这个模式划分为三块。但是这样却不够合理，一个系统的组件划分应该有自己鲜明的特征，就像建筑图纸，如果你看到了客厅、厨房、卧室，那这无疑是家的设计，而如果看到的是借阅室、还书区、公共阅读室那这肯定是图书馆。
类似的，系统的组件划分应当是和它的领域相关的，一个新来的同事，应该可以很快的发现这个系统要做的事情。因此划分系统组件时，应当是用例主导的，并且不同用例的功能应当遵循单一职责原则进行隔离。识别出核心业务逻辑，所谓核心，就是这个业务中与赚钱最为相关的一部分逻辑。梳理依赖关系时，核心逻辑应当处于最顶层/或者是同心圆的最里层，其他模块依赖它，而它不会依赖下层的模块，下/外面一层是用例的处理逻辑，再外一层是展现/存储的转换层（presenter），最下/外一层是真正的展现/存储。
引入转换层，是因为 GUI 是难于测试的，而测试应当是系统的一部分（是的，系统不只包括开发功能的代码），为了避免出现系统无法测试的情况，展现部分应当没有任何处理逻辑，这些逻辑应当放在转换层，从而将系统从转换层这里划分为可测试部分和不可测试部分。而测试在系统中所处位置，是属于最底层/外层，它依赖于所需测试的模块，而没有模块依赖于它。但是测试不应当与功能模块耦和，避免出现功能模块一个小的改动，导致测试模块成千的失败。另外，必要时，应当为测试编写专门的 API，以便跳过各种安全、权限检查。
GUI 只是一种展现方式，而 Web 只是一种 GUI方式，因此设计系统时，这部分属于实现细节，决策应当向后推迟，以便支持更多的展现方式，或者说遵循 OCP 原则，在后续有新的展现需求时可以更容易扩展。另外的展现方式还有 CLI 。
数据库也只是一种实现细节，数据库的表/行结构如此流行，只不过是因为内存不够大/硬盘不够快，如果没有这样的限制，应当尽可能选择利于程序使用的结构，比如栈、堆、数组、哈希表等。另外的存储方式包括文件、缓存等。因此关于存储的决策也应当尽可能延迟。
不要迷信框架，对框架的使用程度，可以使用框架便利开发，但是不应当在业务逻辑中出现对框架的依赖，即保持框架可以方便地被去除/替换。
架构的价值在于，使得系统开发的成本尽量降低。
在系统全周期（开发、部署、运行、维护）中，好的架构都发挥着作用。开发时，系统架构应当和开发团队相匹配，方便系统开发；部署时，保持不同组件的独立性，修改其中一个不需要全部重新部署；运行时，好的架构应该可以起到解释系统运行过程的作用；维护包括系统的捉虫以及新需求的 patch，是整个周期中成本最高的，好的架构通过遵循开闭原则以及接口隔离原则，使得 debug 可以尽量少的影响原来代码，并方便扩展新加功能。
好的架构应当使得系统的可选项尽可能久的尽可能多。</description>
    </item>
    
  </channel>
</rss>