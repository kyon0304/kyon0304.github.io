<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on kyon's wonderland with ❤️</title><link>https://kyon.life/tags/java/</link><description>Recent content in java on kyon's wonderland with ❤️</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 17 Jan 2021 15:10:12 +0800</lastBuildDate><atom:link href="https://kyon.life/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 spring cloud openfeign 的一些小技巧</title><link>https://kyon.life/post/tricks-with-feign/</link><pubDate>Sun, 17 Jan 2021 15:10:12 +0800</pubDate><guid>https://kyon.life/post/tricks-with-feign/</guid><description>spring cloud openfeign（以下简称 feign） 通过一个额外定义的 interface 文件作为接口定义，可以将对外提供的 HTTP 接口转换为 API 接口，提供方和调用方需要共同依赖接口文件，将隐式的依赖关系显性表示出来。而且在这个接口文件上也可以大作文章，比如配置服务发现、接口拦截操作等。
一个最简单的 feign 接口文件 DemoClient.java：
1 2 3 4 5 6 7 8 package com.example.demo; @FeignClient(name=&amp;#34;demo&amp;#34;, url=&amp;#34;http://127.0.0.1:8081/&amp;#34;) public interface DemoClient { @GetMapping(&amp;#34;/hello&amp;#34;) String hello(@RequestParam String name); } name 为全局唯一，是这个 FeignClient 的唯一标识，url 为提供方的接口地址。理论上 FeignClient 文件由接口提供方作为合约文件给到调用方，但是即使提供方未提供，只要提供方暴露了 HTTP 接口，那么调用方就可以通过定义 FeignClient 文件将 HTTP 接口调用转换为 API 调用。
调用方使用 DemoClient 示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.</description></item><item><title>第三章 垃圾收集器与内存分配策略</title><link>https://kyon.life/post/java-garbage-collector/</link><pubDate>Mon, 23 Nov 2020 21:53:51 +0800</pubDate><guid>https://kyon.life/post/java-garbage-collector/</guid><description>3.3 垃圾收集算法 分代假说 从如何判定对象消亡的角度，垃圾收集算法可以分为两大类：「引用计数式垃圾收集」和「追踪式垃圾收集」，主流 Java 虚拟机都采用第二种。
分代垃圾收集理论基于三个假设：
弱分代假说：大部分对象都是朝生夕死 强分代假说：活过越多次垃圾回收的对象越不容易被回收 跨代引用假说：跨代引用相对于同代引用来说占比极少 因此应当将内存划分为不同区域，根据对象存活过的回收年龄放到不同区域，适用不同的回收算法，对象间即使存在跨代引用，也是极少数，不需要扫描整个老年代，只需要通过记忆集存储即可。泛泛而论，大部分对象位于新生代，适用标记-复制算法回收，熬过多轮回收的对象位于老年代，适用标记-整理算法。
标记-清除算法 最初始、最基本的追踪式垃圾回收算法，先标记出需要回收的对象，然后清除，相应内存位置变为可用状态。容易产生内存碎片。
标记-复制算法 简称为复制算法，为了解决内存碎片问题，留出一半空间不使用，开始回收内存时，先标记，然后将不可回收对象复制到未使用空间，另外一半空间直接清除。时间效率高，但是浪费一半空间。
基于 IBM 一项研究，新生代对象 98% 都可以在第一次垃圾回收时被回收掉，因此可以降低空间浪费，hotspot 虚拟机中，新生代分为 eden、s0、s1 三个区域，大小比例为 8:1:1 空间浪费由 50% 降低为 10%。新生成对象先进入 eden 区，s0, s1 两个区域总有一个保持未使用状态，假设开始垃圾回收时，s1 未使用，将不可回收对象放入 s1，然后清除 eden 和 s0。如果 s1 不够用，就放入老年代。
标记-整理算法 如果存活对象过多，比如老年队，标记-复制算法的效率就会显而易见降低。而且，如果不想浪费 50% 空间，就必须有另外的担保空间，在 s0 或 s1 区域不够放时接住对象。
在标记-清除算法基础上改进，标记完毕后，不是直接清除可回收对象，而是将存活对象移动到内存区域一端，然后将剩下的区域清除，相当于做了个整理操作。
移动存活对象，垃圾回收过程会复杂，执行效率低，并且需要 stop the world，不移动存活对象，由于内存碎片，内存分配过程会复杂。但是总体而言，还是移动存活对象会使得整个内存使用的吞吐量更高。关注低延迟的 CMS 是基于标记-清除算法，关注总吞吐量的 Parallel Scavenge 是基于标记-整理算法。内存碎片过多时，CMS 会触发一次内存整理。
3.4 Hotspot 虚拟机的算法细节实现 枚举根节点 GC Roots 遍历需要 stop the world，因此要尽可能快，由于 Java 虚拟机主流基本都使用准确式内存管理，即记录了内存中数据类型，因此使用 (Ordinary Object Pointer)OOPMap 数据结构记录对象引用就可以快速拿到所有 GC Roots。</description></item><item><title>Threadlocal 梳理</title><link>https://kyon.life/post/threadlocal/</link><pubDate>Sun, 22 Dec 2019 18:24:10 +0800</pubDate><guid>https://kyon.life/post/threadlocal/</guid><description>使用场景 用于同一线程中，不同类、不同方法间数据共享。没有 ThreadLocal 的帮助，这些需要共享的数据，就必须通过参数、返回值进行传递，将会变得非常繁琐。常见的使用场景，比如存储登录用户信息，同一个 request 的 trace id 等。
实现 ThreadLocalMap 是 ThreadLocal 的静态内部类，Entry 是 ThreadLocalMap 的静态内部类，其中 Entry 是弱引用的子类，referent 指向 threadlocal 对象，value 成员变量则是真正存储用户设置的值的地方。
如何存储 首先，用一张图来表示一下 threadlocal 是如何存储数据的：
可以看到，用户关心的数据存储在 ThreadLocal 内部静态类 Entry 的 value 成员变量中，Entry 类型的变量有多个，组成数组 table，由 ThreadLocalMap 的实例所持有，而 ThreadLocalMap 实例则是线程的成员变量 threadlocals。因此，当多线程环境下访问同一个类实例的 ThreadLocal 变量时，其实每个线程都有各自的 ThreadLocalMap 变量 threadlocals，从而持有各自的 Entry 及其 value。这就是 ThreadLocal 如何做到线程安全的，不同线程使用的是不同副本。
ThreadLocalMap 内部维护了一个 Entry[] 类型的数组变量 table，索引 Entry 的实例时，有两种方式，一种是通过 hashcode 计算快速定位，另外一种是快速定位失效时，使用 threadlocal 实例循环比对 entry 的 referant。
ThreadLocal, ThreadLocalMap, Entry 三者的套娃定义如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 public class ThreadLocal&amp;lt;T&amp;gt; { static class ThreadLocalMap { static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?</description></item></channel></rss>