<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>笔记 on kyon's wonderland with ❤️</title><link>https://kyon.life/tags/%E7%AC%94%E8%AE%B0/</link><description>Recent content in 笔记 on kyon's wonderland with ❤️</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 31 Aug 2021 22:45:12 +0800</lastBuildDate><atom:link href="https://kyon.life/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>操作系统导论学习笔记（一）</title><link>https://kyon.life/post/ostep-1/</link><pubDate>Tue, 31 Aug 2021 22:45:12 +0800</pubDate><guid>https://kyon.life/post/ostep-1/</guid><description>为了让程序运行变得更容易，操作系统出现了。操作系统完成的事情包括，允许多个程序同时运行、让程序共享内存、让程序能够与设备交互等。操作系统负责确保系统既易于使用又正确高效的运行。操作系统通过虚拟化（virtualization）做到这一点，操作系统将物理资源（如 CPU、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机(virtual machine)
设计和实现操作系统的目标 提供高性能，尽可能降低操作系统的性能开销 minimize the overhead 在应用程序之间以及操作系统和应用系统之间提供保护 protection 让进程间彼此隔离是实现保护的关键 isolation 保证高可靠性 reliability 能源效率 energy efficiency, 安全性 security, 移动性 mobility 操作系统的 3 个“简单”部分 虚拟化 virtualizing 持久性 persistence 并行 concurrency 虚拟化 virtualizing 虚拟化又分为虚拟化 CPU 和虚拟化内存。
虚拟化 CPU
在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟CPU的假象。将单个CPU（或其中一小部分）转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU（virtualizing the CPU）
虚拟化内存
每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。但实际情况是，物理内存是由操作系统管理的共享资源。
持久化 persistence 内存 DRAM 中的数据是易失的，如果断电或系统崩溃，内存中的数据都会丢失。因此我们需要硬件和软件支持来持久地存储数据。
硬件以某种输入/输出设备（Input/Output, I/O）的形式出现。
操作系统中管理磁盘的软件通常称为文件系统（file system）。因此它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。
关键问题：如何持久地存储数据
文件系统是操作系统的一部分，负责管理持久的数据。持久性需要哪些技术才能正确地实现？需要哪些机制和策略才能高性能地实现？面对硬件和软件故障，可靠性如何实现？
并行 concurrency 关键问题：如何构建正确的并发程序
如果同一个内存空间中有很多并发执行的线程，如何构建一个正确工作的程序？操作系统需要什么原语？硬件应该提供哪些机制？我们如何利用它们来解决并发问题？
操作系统的简单历史 早期操作系统：只是一些库 引入保护机制：借助硬件的帮助，区分用户模式和内核模式 多道程序 multiprogram: 提高 CPU 执行效率，避免 I/O 处理拖慢 CPU 执行。出现 Unix 摩登时代：出现个人计算机，遗憾的是，对于操作系统来说，个人计算机起初代表了一次巨大的倒退，因为早期的系统忘记了（或从未知道）小型机时代的经验教训。幸运的是，经过一段时间的苦难后，小型计算机操作系统的老功能开始进入台式机。</description></item><item><title>第三章 垃圾收集器与内存分配策略</title><link>https://kyon.life/post/java-garbage-collector/</link><pubDate>Mon, 23 Nov 2020 21:53:51 +0800</pubDate><guid>https://kyon.life/post/java-garbage-collector/</guid><description>3.3 垃圾收集算法 分代假说 从如何判定对象消亡的角度，垃圾收集算法可以分为两大类：「引用计数式垃圾收集」和「追踪式垃圾收集」，主流 Java 虚拟机都采用第二种。
分代垃圾收集理论基于三个假设：
弱分代假说：大部分对象都是朝生夕死 强分代假说：活过越多次垃圾回收的对象越不容易被回收 跨代引用假说：跨代引用相对于同代引用来说占比极少 因此应当将内存划分为不同区域，根据对象存活过的回收年龄放到不同区域，适用不同的回收算法，对象间即使存在跨代引用，也是极少数，不需要扫描整个老年代，只需要通过记忆集存储即可。泛泛而论，大部分对象位于新生代，适用标记-复制算法回收，熬过多轮回收的对象位于老年代，适用标记-整理算法。
标记-清除算法 最初始、最基本的追踪式垃圾回收算法，先标记出需要回收的对象，然后清除，相应内存位置变为可用状态。容易产生内存碎片。
标记-复制算法 简称为复制算法，为了解决内存碎片问题，留出一半空间不使用，开始回收内存时，先标记，然后将不可回收对象复制到未使用空间，另外一半空间直接清除。时间效率高，但是浪费一半空间。
基于 IBM 一项研究，新生代对象 98% 都可以在第一次垃圾回收时被回收掉，因此可以降低空间浪费，hotspot 虚拟机中，新生代分为 eden、s0、s1 三个区域，大小比例为 8:1:1 空间浪费由 50% 降低为 10%。新生成对象先进入 eden 区，s0, s1 两个区域总有一个保持未使用状态，假设开始垃圾回收时，s1 未使用，将不可回收对象放入 s1，然后清除 eden 和 s0。如果 s1 不够用，就放入老年代。
标记-整理算法 如果存活对象过多，比如老年队，标记-复制算法的效率就会显而易见降低。而且，如果不想浪费 50% 空间，就必须有另外的担保空间，在 s0 或 s1 区域不够放时接住对象。
在标记-清除算法基础上改进，标记完毕后，不是直接清除可回收对象，而是将存活对象移动到内存区域一端，然后将剩下的区域清除，相当于做了个整理操作。
移动存活对象，垃圾回收过程会复杂，执行效率低，并且需要 stop the world，不移动存活对象，由于内存碎片，内存分配过程会复杂。但是总体而言，还是移动存活对象会使得整个内存使用的吞吐量更高。关注低延迟的 CMS 是基于标记-清除算法，关注总吞吐量的 Parallel Scavenge 是基于标记-整理算法。内存碎片过多时，CMS 会触发一次内存整理。
3.4 Hotspot 虚拟机的算法细节实现 枚举根节点 GC Roots 遍历需要 stop the world，因此要尽可能快，由于 Java 虚拟机主流基本都使用准确式内存管理，即记录了内存中数据类型，因此使用 (Ordinary Object Pointer)OOPMap 数据结构记录对象引用就可以快速拿到所有 GC Roots。</description></item></channel></rss>