<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>实操 on kyon&#39;s wonderland with ❤️</title>
    <link>https://kyon.life/tags/%E5%AE%9E%E6%93%8D/</link>
    <description>Recent content in 实操 on kyon&#39;s wonderland with ❤️</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 17 Feb 2020 21:32:03 +0800</lastBuildDate>
    
	<atom:link href="https://kyon.life/tags/%E5%AE%9E%E6%93%8D/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使线上 Spring 应用更好部署和调试</title>
      <link>https://kyon.life/post/spring-config/</link>
      <pubDate>Mon, 17 Feb 2020 21:32:03 +0800</pubDate>
      
      <guid>https://kyon.life/post/spring-config/</guid>
      <description>运行一个配置中心，可以方便快捷的更改线上服务多个实例的配置（通过 git commit&amp;amp;git push），配置中心通过服务发现暴露自己的 IP，client 中无需写死 server 地址，在 k8s 中部署也更自然。
运行一个可视化的应用详情 server，可以直观的看到应用健康监控、应用运行的包的构建时间及代码 commit id，应用当前生效的属性并可以动态修改，应用精确到类的日志级别，并可以动态修改。
要做到以上的事情，主要涉及四个组件的配置：
 spring-cloud-config spring-boot-admin spring-zookeeper-discovery spring-boot-actuator  效果展示 配置完成后效果图如下，主要是可视化的应用详情部分的展示，关于配置中心的使用方式的话，目前没有界面，主要就是对 spring-cloud-config server 后端数据的修改，然后 spring 有机制可以让它们动态生效，至少应用重启后可以覆盖 jar 包中的属性配置。
  一个美观页面，主要展示了三种信息：
 服务运行了多长时间 当前起的服务: configserver 和 cloud-adapter-aws，是从服务的 spring.application.name 取值 每个服务有几个实例，目前本地测试环境起的，都只有一个实例 服务的版本信息，从 pom.xml 文件种读的 &amp;lt;version&amp;gt;0.1.0&amp;lt;/version&amp;gt;   右上角切换到 Applications 的页面，以数字+列表形式展示了服务统计信息，当服务比较多的时候这个页面会更直观一些，另外当一个服务有多个实例时，可以从这个页面区分不同实例进入到详情页面。
 这里进入 cloud-adapter-aws 服务的一个实例页面，左侧导航栏有三部分，默认进入 Details 这一项。
页面上我会比较关注的部分，
 git 信息，包括 commit id，时间，分支 build 信息，包括版本号，构建时间，当线上出现问题时，可以通过 1，2 这两条信息快速定位到部署对应的包以及代码 健康状态监控，由 /actuator/health 返回的信息稍微规整了一下，可以快速看到依赖的第三方应用比如 mq、zk、db（如果使用了的话） 等组件的健康状态展示出来。另外也可以通过配置包含一些详细信息比如下面的 4 和 5 使用了 spring cloud discovery 的话，会把可以看到的 client 也展示出来 使用了 spring cloud config 的话，会把 config 加载的地址展示出来   这个页面展示了应用从各个地方加载的属性值，包括 application.</description>
    </item>
    
    <item>
      <title>基于 Spring Boot &#43; Disconf 的配置中心</title>
      <link>https://kyon.life/post/config-server-with-spring-boot-and-disconf/</link>
      <pubDate>Sun, 03 Nov 2019 13:01:01 +0800</pubDate>
      
      <guid>https://kyon.life/post/config-server-with-spring-boot-and-disconf/</guid>
      <description>disconf 简介 disconf 是百度的某位员工开源的分布式配置中心，文档地址，C/S 架构，客户端通过监听 zookeeper 中更新触发配置拉取，服务端自带一个简陋前端可以用于图形化查看/更新配置。相比于 spring boot admin 中提供的 refresh context 功能，优势在于可以一次更改，应用于所有同类机器配置，而 spring boot admin 需要对每个实例进行单独修改。除此之外，spring boot admin 在界面及交互上吊打 disconf。
设计架构  server 端包含 springmvc 用于处理业务逻辑，mysql 用于存储配置文件，两个 redis 用于用户登录，zk 用于配置更新的通知， web 端用于用户登录后统一查看/更新配置 client 端以 pom 方式引入项目内即可（需要魔改一下，见后）  运行流程 启动事件A： 以下按顺序发生。
 A3：扫描静态注解类数据，并注入到配置仓库里。 A4+A2：根据仓库里的配置文件、配置项，去 disconf-web 平台里下载配置数据。这里会有主备竞争 A5：将下载得到的配置数据值注入到仓库里。 A6：根据仓库里的配置文件、配置项，去ZK上监控结点。 A7+A2：根据XML配置定义，到 disconf-web 平台里下载配置文件，放在仓库里，并监控ZK结点。这里会有主备竞争。 A8：A1-A6均是处理静态类数据。A7是处理动态类数据，包括：实例化配置的回调函数类；将配置的值注入到配置实体里。  更新配置事件B： 以下按顺序发生。
 B1：管理员在 Disconf-web 平台上更新配置。 B2：Disconf-web 平台发送配置更新消息给ZK指定的结点。 B3：ZK通知 Disconf-cient 模块。 B4：与A4一样。 B5：与A5一样。 B6：基本与A4一样，唯一的区别是，这里还会将配置的新值注入到配置实体里。  主备机切换事件C： 以下按顺序发生。</description>
    </item>
    
  </channel>
</rss>