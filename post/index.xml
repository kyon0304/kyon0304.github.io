<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on kyon&#39;s wonderland with ❤️</title>
    <link>https://kyon.life/post/</link>
    <description>Recent content in Posts on kyon&#39;s wonderland with ❤️</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 23 Nov 2020 21:53:51 +0800</lastBuildDate>
    
	<atom:link href="https://kyon.life/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>第三章 垃圾收集器与内存分配策略</title>
      <link>https://kyon.life/post/java-garbage-collector/</link>
      <pubDate>Mon, 23 Nov 2020 21:53:51 +0800</pubDate>
      
      <guid>https://kyon.life/post/java-garbage-collector/</guid>
      <description>3.3 垃圾收集算法 分代假说 从如何判定对象消亡的角度，垃圾收集算法可以分为两大类：「引用计数式垃圾收集」和「追踪式垃圾收集」，主流 Java 虚拟机都采用第二种。
分代垃圾收集理论基于三个假设：
 弱分代假说：大部分对象都是朝生夕死 强分代假说：活过越多次垃圾回收的对象越不容易被回收 跨代引用假说：跨代引用相对于同代引用来说占比极少  因此应当将内存划分为不同区域，根据对象存活过的回收年龄放到不同区域，适用不同的回收算法，对象间即使存在跨代引用，也是极少数，不需要扫描整个老年代，只需要通过记忆集存储即可。泛泛而论，大部分对象位于新生代，适用标记-复制算法回收，熬过多轮回收的对象位于老年代，适用标记-整理算法。
标记-清除算法 最初始、最基本的追踪式垃圾回收算法，先标记出需要回收的对象，然后清除，相应内存位置变为可用状态。容易产生内存碎片。
标记-复制算法 简称为复制算法，为了解决内存碎片问题，留出一半空间不使用，开始回收内存时，先标记，然后将不可回收对象复制到未使用空间，另外一半空间直接清除。时间效率高，但是浪费一半空间。
基于 IBM 一项研究，新生代对象 98% 都可以在第一次垃圾回收时被回收掉，因此可以降低空间浪费，hotspot 虚拟机中，新生代分为 eden、s0、s1 三个区域，大小比例为 8:1:1 空间浪费由 50% 降低为 10%。新生成对象先进入 eden 区，s0, s1 两个区域总有一个保持未使用状态，假设开始垃圾回收时，s1 未使用，将不可回收对象放入 s1，然后清除 eden 和 s0。如果 s1 不够用，就放入老年代。
标记-整理算法 如果存活对象过多，比如老年队，标记-复制算法的效率就会显而易见降低。而且，如果不想浪费 50% 空间，就必须有另外的担保空间，在 s0 或 s1 区域不够放时接住对象。
在标记-清除算法基础上改进，标记完毕后，不是直接清除可回收对象，而是将存活对象移动到内存区域一端，然后将剩下的区域清除，相当于做了个整理操作。
移动存活对象，垃圾回收过程会复杂，执行效率低，并且需要 stop the world，不移动存活对象，由于内存碎片，内存分配过程会复杂。但是总体而言，还是移动存活对象会使得整个内存使用的吞吐量更高。关注低延迟的 CMS 是基于标记-清除算法，关注总吞吐量的 Parallel Scavenge 是基于标记-整理算法。内存碎片过多时，CMS 会触发一次内存整理。
3.4 Hotspot 虚拟机的算法细节实现 枚举根节点 GC Roots 遍历需要 stop the world，因此要尽可能快，由于 Java 虚拟机主流基本都使用准确式内存管理，即记录了内存中数据类型，因此使用 (Ordinary Object Pointer)OOPMap 数据结构记录对象引用就可以快速拿到所有 GC Roots。</description>
    </item>
    
    <item>
      <title>Spring 框架缓存故障自动切换</title>
      <link>https://kyon.life/post/dynamic-switch-cache-in-spring/</link>
      <pubDate>Tue, 29 Sep 2020 15:40:36 +0800</pubDate>
      
      <guid>https://kyon.life/post/dynamic-switch-cache-in-spring/</guid>
      <description>现状 缓存只是提高访问速度，应用本身没有很高的并发访问量，缓存不可用时，数据库也能顶住。但是缓存挂掉以后，Spring CacheManager 默认会抛出异常，方法直接就异常退出了。
目标 缓存不可用时，不影响应用正常运行，不影响接口正常返回。
解决方案 方案一 最直接的方案，Spring 定义的 error handler 默认是抛出异常，覆盖 handler 并 catch 住异常不要抛出就可以不影响正常处理流程。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class CacheErrorLoggingHandler extends SimpleCacheErrorHandler {private Logger logger = LoggerFactory.getLogger(CacheErrorLoggingHandler.class);private ClientResources clientResources;public void setClientResources(ClientResources clientResources) {this.clientResources = clientResources;}@Overridepublic void handleCacheGetError(RuntimeException exception, Cache cache, Object key) {logger.</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第三章 仅仅能工作的代码是不够的（编程时的战略 vs 战术思维）</title>
      <link>https://kyon.life/post/philosophy-of-software-design-3/</link>
      <pubDate>Mon, 24 Feb 2020 11:45:01 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-3/</guid>
      <description>好的系统设计最重要的元素之一是完成编程任务时所采取的思考方式。许多组织鼓励使用战术性思维，专注于尽快使功能上线工作。然而，如果想获得好设计，则必须采取战略思维，在简洁的设计和修复问题上投入更多时间。这章讨论了为什么采用战略思维可以获得更好的设计，而且从长远来看，实际上要比战术思维更节省时间。
3.1 战术式编程 大多数程序员采用我称为战术式编程的方式进行软件开发。这种方式中，主要关注点是得到能工作的东西，比如一个新功能或修复一个 bug。第一眼看去，似乎完全合理：还有什么能比写出可以工作的代码更重要呢？然而，战术式编程很明显不能产生一个好的系统设计。
战术式编程的问题在于短视。采用战术式思维编程时，你就会尽快地完成一项任务。可能面临着硬性规定的截止时间。最终，为未来做计划的优先级就会变低。你不会在寻找最好的设计上花费太多时间；你只是想要尽快获得可以工作的代码。你会自我催眠，认为如果可以更快地完成当前任务，那么增加一点复杂度或者混入一两个不和谐因素也没什么问题。
这就是系统如何变复杂的。正如前一章中讨论的那样，复杂性是增量的。并不是某一个特定的问题，而是数十或数百个小问题的积累使得系统变复杂了。如果你采用战术式编程，每一个编程任务都会向这些复杂性做贡献一些问题。每一个问题可能看上去都是为了快速完成当前任务的合理折中。然而，复杂性会迅速积累，尤其是如果每个人都采用战术式编程的话。
不久之后，一些复杂性就会开始导致问题，你将会开始希望当时没有走捷径。但是，你仍会告诉自己，使得下一个功能尽快工作要比反过头来重构已有代码重要得多。长远来看重构可能可以帮得上忙，但是绝对会拖慢当前任务的进度。所以，对于碰到的任何问题，你就会寻找可以解决它的快速补丁，而这又会在将来需要更多的补丁。很快代码就会变成一团糟，但是此时想要清理代码的话将耗费数月的工作。你的日程不可能负担得起这样的延迟，而且修复其中一两个问题看上去也不会有什么效果，所以你会仍旧保持战术式编程。
如果你曾经在一个大型软件项目中工作过很久，我猜你曾经在工作中见过战术式编程并且经历过它带来的问题。一旦你开始采用这种方式，就很难做出改变。
几乎每个软件开发公司都至少有一名把战术式编程发挥到极致的开发人员：战术式飓风。战术式飓风是一名高产的程序员，他地代码产出速度比其他人快得多，但是完全以战术式思维的方式工作。当涉及实现一个快速功能时，没有人可以比战术式飓风更快的完成。在一些公司中，管理层将战术式飓风视为英雄。然而，战术式飓风会留下一系列破坏痕迹。他们很少被将来必须和他写的代码打交道的工程师视为英雄。通常，其他工程师必须清理战术式飓风造成的混乱，这会使得这些工程师（真正的英雄）看上去比战术式飓风的进度更慢。
3.2 战略式编程 成为一个好的系统设计师的第一步是要意识到 仅仅能工作的代码是不够的。 为了完成当前任务而引入不必要的复杂性是不可接受的。更重要的是系统的长期结构。任何系统中的大多数代码都是在已有代码的基础上扩展而来的，所以作为开发者最重要的工作是为那些将来的扩展提供便利。因此，不应当把“可以工作的代码”当作首要目标，尽管你的代码当然必须可以工作。你的首要目标必须是获得好设计，然后也恰好可以工作。这就是 战略式编程。
战略式编程要求有投资的思维。相较于采取最快的方式完成当前项目，你必须投资一些时间提升系统的设计。这些投资短期看会稍微拖慢你的进度，但是长期来看它们会加速你的开发，如图 3.1 所示。
一些投资是主动的。比如，为每个新建的类多花一点时间找到简单的设计是值得的；与其实现蹦到脑子里的第一个主意，不如尝试一些其他的设计并选择其中最简洁的。试着想象一下未来系统可能会向哪些方向改变，并且保证你的设计可以使得这些改变会很容易。编写良好的文档是主动投资的另外一个例子。
其他投资将会是被动的。不管你前期投资了多少，你的设计决定不可避免地会出现错误。随着时间流逝，这些错误会变明显。当你发现了一个设计问题，不要忽略它或仅仅通过打补丁解决；花费一些额外的时间来修复它。如果采用战略式编程，你将会对系统设计持续性地做出小改善。这是战术式编程的反面，那种方式下你会持续性地增加复杂性并在将来引发问题。
3.3 投资多少时间？ 所以，投资的时间正确数量是多少呢？巨大的前期投资，比如尝试设计整个系统，是低效的。这是瀑布式方法，而且我们知道它不奏效。理想的设计倾向于随着你获得系统的经验而一点点地出现。因此，最好的方式是在连续的基础上作出大量的投资。我建议花费大约占开发时间的 10-20% 在前期投资上。这个数量足够小，不会显著影响你的日程安排，但是又足够大，可以随着时间获得明显的收益。因此你最初的项目花费的时间要比纯粹的战术式方式长 10-20%。这个额外的时间会导致更好的软件设计，并且几个月内你就会开始享受这些好处。不久之后，你的开发速度就会比当时以战术式编程的人快至少 10-20% 。到这个时候，你的投资就会变成免费的了：从你过去的投资中的获益将会节省足够多的时间覆盖将来的投资。你将会快速地从初始的投资中恢复。图 3.1 展示了这种现象。
  图 3.1：开始，战术式编程会比战略式编程进度更快。然而，战术方式下复杂性会更快地积累。随着时间流逝，战略方式进度会更快。注意：这张图只是定性的说明；我不知道任何可以对这个曲线进行精确测量的经验
  相反，如果你采用战术式编程，你将会更快地完成第一个项目，但是随着时间流逝，你的开发速度会随着复杂性累积而变慢。你将会很快地将开始节省的时间还回去，而且在这个系统剩下的生命中，你的开发速度会越来越慢。如果你从未在糟糕的代码基础上工作过，和其他有过这种经历的人聊一聊；他们会告诉你糟糕的代码质量至少会拖慢 20% 的开发速度。
3.4 初创企业和时间投资 在一些环境中有着强大的力量反对战略式方式。比如，早期的初创企业有着将他们的早期版本发布出去的巨大压力。在这些公司中，看上去即使是 10-20% 的投资也支付不起。最终，许多初创企业采取了战术方式，在设计上花费的时间很少，清理出现的问题时花费的时间甚至更少。他们用这样的想法将这些行为合理化：如果他们成功了，他们会有足够的钱雇佣更多的工程师来做清理。
如果你在有这种倾向的公司中，你应当已经意识到，一旦代码库变混乱，想要修复基本是不可能的。在这个产品的生命中你可能需要支付很高的研发花费。而且，好（或坏）设计的报应来得非常快，所以，战术方式很可能甚至无法加速你第一个产品的发布。
另外一件需要考虑的事情是，公司成功的最关键的因素之一是它的工程师的质量。降低开发花销的最好的方式是雇佣厉害的工程师：他们的成本不比平庸的工程师多多少，但是他们有着高得多的产出。然而，最好的工程师非常关注好的设计。如果你的代码库一团糟，事情会传出去，你会更难进行招聘。最终，你很可能只能拥有平庸的工程师。这回增加未来的花费，而且很可能会导致系统结构进一步降级。
Facebook 就是一个鼓励战术编程的初创企业的例子。很多年来这家公司的座右铭是“快速行动并打破东西。”刚刚从大学毕业的新入职工程师被鼓励立即深入公司的代码库；工程师在他们入职的第一周就向线上提交代码曾经是很常见的。积极的一面是，Facebook 作为一家给员工赋权的公司而闻名。工程师有着巨大的自由，基本没有什么规则和约束阻碍他们。
Facebook 作为一家公司曾经非常成功，但是它的代码库由于公司的战术方式而遭受了损失；大多数代码都不稳定而且难以理解，基本没有注释和测试，使用时非常痛苦。随着时间流逝，这家公司意识到它的文化是不可持续的。最终，Facebook 把座右铭变为“在坚实的基础架构上快速行动”来鼓励它的工程师在好的设计上投资更多时间。Facebook 是否能成功地清理数年来战术式编程累积地问题还有待观察。
对 Facebook 讲句公道话，我应当指出 Facebook 的代码可能不比初创企业的平均水平差多少。初创企业中战术式编程是家常便饭；Facebook 只是恰好是一个特别明显的例子。
幸运的是，采用战略方式也可能在硅谷中成功。Google 和 VMware 差不多和 Facebook 同时起家，但是这两家公司都拥抱了更战略化的方式。它们都很重视代码的质量和好的设计，而且都基于可信赖的软件系统构建了解决复杂问题的精致的产品。这些公司强烈的工程文化在硅谷变得出名。很少能有别的公司可以在招聘顶级人才中竞争得过它们。
这些例子表明公司可以以任一种方式成功。然而，在关注软件设计并拥有干净代码库的公司工作要有趣得多。
3.5 结论 好的设计不是免费的。你必须持续性的进行投资，这样小的问题就不会积累成大问题。幸运的是，好设计最终会偿付它自己，而且比你认为的要更快。</description>
    </item>
    
    <item>
      <title>修改博客主题</title>
      <link>https://kyon.life/post/change-theme/</link>
      <pubDate>Fri, 21 Feb 2020 18:39:03 +0800</pubDate>
      
      <guid>https://kyon.life/post/change-theme/</guid>
      <description>没有记录的就没有存在过。所以稍微记录一下。其实不是第一次折腾主题了，之前应 邹扒皮 之约，研究过一次的 Jekyll 的 Next 主题，当然是别人 port 到 Hugo 的版本，但是最终放弃了，因为各种细节都很粗糙，我也没有想要改的动力。
这次是昨天看到 kubectl-debug 的作者的 博客，文章宽度更宽一些，超链接样式很可爱，图例也有专门的样式，文章的 meta 信息也不那么抢眼，总之就是撞到我心坎里了吧，然后看了下也是 hugo 主题，之前其实就想换主题来着，一直没找到心仪的，于是决定这次就把现在的主题换掉。
哦对了，新主题是 Hermit。
下面说一说替换主题都做了什么修改。
之前用 even 的时候其实也做了一些定制化，比如分享啊，把目录从文章右侧挪到左边啊，根据文章 front Matter 里的 keyword 加推荐阅读啊，这种小小的修改。之前涉及到样式的修改，是先安装 node 和 yarn，然后在 even 目录里 yarn install/build 这样非常笨地在做，这次在 Hermit 的 ReadMe 里看到只要下载 extended 的 hugo 就可以编译 scss 了，之前要是知道的话能省不少事。
不打算写成教程向的，纯粹随缘记录。
遇到第一个麻烦的事情是，Hermit 的主题颜色只有一种，没有像 even 那样定义成不同主题一键切换，不过总的来说用到的颜色也不多，只是自己用，全局查找替换一下不是什么问题。问题是，要用什么颜色。。这个花了蛮久的，在这个网站上复制粘贴了很多色值，一个个试的，其实底部栏的颜色也不是特别满意，但实在已经试到心焦气燥了，就先这样。
然后是解决目录不显示的问题，even 里是在全局和文章的 front matter 变量两个地方同时控制，并且文章的优先级高一些，hermit 是只能用文章的 front matter 变量。但是我现有的文章都没有显示指定，直接在全局变量设置的，于是想改成和 even 一样的逻辑。但是试来试去，目录就是不出现，后来发现 hermit 的目录有两个地方，一个是文章目录本录，另外一个是文章右下角的目录开关，即使有目录也要先按开关切换以后才会出现，很不爽啊，于是直接改了下目录 css 类，让它直接显示，后面修改是否出现目录的逻辑也就水到渠成了。
想起来，第一个事情应该是修改配置文件，从 exampleSite 里拷贝出来的默认的配置文件是 toml 格式的，但是上次折腾推荐阅读的时候发现，其实对 yaml 的支持度更好，于是那时就换成了 yaml 格式。只是当时比较直愣愣，一行一行手动改的，今天突然想起了应该有 convert 工具啊，hugo 确实有个子命令是 convert，但可惜是转换文章 front matter 格式的，于是上网随便搜了个网站转了下，复制粘贴回来。然后照着之前 even 主题时候的配置增删改查一下。说到这里不得不提一下，even 的配置还是蛮良心的，量大，还有注释。这次修改去掉了不少配置，包括 busuanzi 的 PV/UV 统计，虽然之前一直看一直看，但它总是不变看着也闹心啊。留了一个 GgoogleAnalytics，以后想起来去看看就得了。</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第二章 复杂度的天性</title>
      <link>https://kyon.life/post/philosophy-of-software-design-2/</link>
      <pubDate>Wed, 19 Feb 2020 12:15:39 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-2/</guid>
      <description>这本书是关于如何设计软件系统使得它们的复杂度最小化。第一步是了解敌人。到底什么是“复杂性”？你怎么知道一个系统是不必要的复杂？什么会导致系统变复杂？这章会在较高层级解决这些问题；余下的章节会就具体结构特征向你展示如何在较低层级识别复杂度。
识别复杂性是设计技能中一项关键的能力。它使得你可以在投入大量精力前发现问题，并且在许多可选项中做出好选择。分辨出一个设计是否简洁要比创造一个简洁的设计容易，但是一旦你可以识别出一个系统过于复杂，你就可以使用这个能力来指导你的设计哲学向着简单性出发。如果一个设计看上去很复杂，尝试一种不同的方式然后看看是否变简单了。随着时间流逝，你会注意到一些特定的技术会得到更简单的设计，另外一些则和复杂性相关。这将使得你能更快地产出更简洁的设计。
本章也会给出一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节会使用本章的材料来评判各种不同的改善方法和结论。
2.1 定义复杂性 为了这本书的目的，我以一种实践方式定义“复杂性”。复杂性是和软件系统结构相关的、使得理解和修改系统更困难的任何东西。 复杂性可能会以很多形式出现。比如，可能难以理解一段代码是如何运行的；可能一点小的改进需要花费很大精力，或者为了做出改进需要修改系统的哪些部分难以确定；可能很难在不引入其他问题的情况下修复一个 bug。如果很难理解和修改一个软件系统，那么它就是复杂的；如果很容易理解和修改，那它就是简单的。
也可以从成本和收益的角度考虑复杂性。在复杂系统中，哪怕是实现一个很小的改进都需要花费很多工作。在简单系统中，可以用更少的工作完成更大的改进。
复杂性是开发者在尝试完成一个特定目标时在特定时间点的经历。并不一定和系统整体的大小或功能相关。人们经常用“复杂（complex）”一词来描述有着复杂（sophisticated）功能的大型系统，但是如果这样的系统开发很容易上手的话，那么，从本书的角度来看，并不复杂（complex）。当然，几乎所有大型和复杂（sophisticated）的软件系统实际上也难以开发，所以它们也符合我这里复杂的定义。但是这并不一定是事实。小型并不复杂（unsophisticated）的系统也有可能非常复杂（complex）。1
复杂性由最常见的活动决定。如果系统中包括一些非常复杂的部分，但是这些基本不会用到，那它们对系统整体的复杂性几乎没影响。用粗略的数学方式来表示：
$$C = ∑c_pt_p$$
系统整体复杂性（C）由每部分的复杂性 （$c_p$）加权开发者在这部分花费的时间（$t_p$）决定。把复杂性隔离在一个从不会被看到的地方基本就和完全消除了复杂性一样。
相较于编写者，复杂性对阅读者来说更明显。如果你编写了一段对你来说似乎很简单的代码，但是其他人认为它复杂，那么它就是复杂的。当你发现你处于这样的境况中，请其他开发者来看一下为什么他们觉得代码很复杂就很值得一试；在你和他们不同的观点中很有可能学到有趣的东西。作为开发者的工作不仅仅是写出你觉得容易的代码，也要让其他人觉得容易。
2.2 复杂性的征兆 复杂性通过三种一般的方式表现出来，下面的段落将会描述到。每一种都会使得完成研发任务变得困难。
 图2.1： 网站的每个页面都会展示有颜色的横幅。(a) 中横幅的背景色是在每个页面中显示指定的。(b) 中共享变量保存背景色的值，每个页面都指向这个变量。(c) 中一些页面会展示额外的颜色表示强调，这个颜色是背景色带阴影的较暗的转换；如果背景色变化了，强调色也必须跟着变化。
  放大改变： 复杂性的第一个征兆是，一个看上去简单的改变需要在许多不同的地方修改代码。比如，考虑有着不同页面的网站，每一个页面都会展示有着背景色的横幅。在很多早期网站中，颜色是由每个页面显示地指定的，如图 2.1(a)。为了改变这个网站的背景色，开发者可能需要手动地修改每个已有页面；对于有着上千张页面的大型网站来说这几乎是不可能的。幸运的是，现代的网站使用了图 2.1(b) 中的方式，横幅颜色在一个集中的地方一次性指定，所有页面都指向这个共享的值。使用这种方式时，整个网站的横幅颜色变化可以由单个修改完成。好的设计的目标之一是，减少每个设计决定会影响到的代码数量，这样修改设计时不需要改动很多代码。
心智负担： 复杂性第二个征兆是心智负担，心智负担是指开发者为了完成任务需要了解多少东西。更高的心智负担意味着开发者不得不花费更多时间学习必需了解的信息，而且可能会由于他们遗漏了一些重要信息而增加出现 bug 的风险。比如，C 中分配内存的函数返回指向内存的指针，并且假设调用者会释放内存。这增加了使用这个函数的开发者的心智负担；如果开发者没能释放内存，那么就会出现内存泄漏。如果可以重构系统使得开发者无需关心内存释放（分配内存的模块同时负责释放它），就可以降低心智负担。心智负担以多种方式出现，比如有许多方法的 API，全局变量，不一致性，模块间依赖。
系统设计者有时候认为可以用代码行数衡量复杂性。他们认为如果一个实现比另外的短，那么肯定就更简单；如果只需要很少几行就可以做出改变，那这个改变肯定很容易。然而，这个视角忽略了和心智负担有关的成本。我曾经见过只需要几行就可以完成一个应用的框架，但是想要搞懂这几行做了什么事情却及其困难。有时候需要更多行代码的方式其实更简单，因为它降低了心智负担。
未知的未知： 复杂性的第三个征兆是，为了完成任务需要修改哪些代码或者开发者需要了解哪些信息并不明显。图 2.1(c) 展示了这个问题。网站使用集中变量来决定横幅背景色，所以看上去很容易修改。然而，一些网页使用了带阴影加深的背景色来表示强调，而这个加深的颜色是在每个页面单独指定的。如果背景色变化了，那强调色也必须相匹配地跟着变化。不幸的是，开发者不太可能意识到这个颜色的存在，所以他们可能修改了集中变量 bannerBg 但是没有更新强调色。即使开发者意识到了这个问题，哪些页面使用了强调色也不明显，所以开发者不得不搜索网站中的所有页面。
复杂性的三种表现方式中，未知的未知是最糟糕的。未知的未知意味着你需要了解一些东西，但是你却无法知道需要了解什么，或者甚至这些东西是否存在。在你修改后，直到出现 bug 之前都无法知道。改变放大很烦人，但是只要知道需要修改哪些代码，一旦完成修改系统还是可以工作。类似的，高的心智负担会增加做出改变的成本，但是如果知道哪些信息需要掌握，改变仍旧很可能是正确的。而未知的未知的情况，你将不知道需要做什么，或者提议的方案是否可以工作。唯一可以确定的方式，是阅读系统的每一行代码，这对任何规模的系统都是不切实际的。即使这样也还不够，因为修改可能依赖于一个从未记录的微小的设计决定。
对于系统来说，好设计的最重要的目标之一是使系统变得浅显易懂。这是高心智负担和未知的未知的对立面。在浅显易懂的系统中，开发者可以快速了解已有代码是如何工作的以及做出修改需要什么。浅显易懂的系统中，开发者可以快速的猜出要做什么，不需要非常认真地思考，而且还可以对猜测很有信心。第十八章讨论了使得代码更浅显易懂的技术。
2.3 复杂性的原因 既然你已经知道了复杂性的高层级的征兆，还有为什么复杂性会使得软件开发变困难，下一步就是搞懂什么导致了复杂性，这样我们就可以在设计系统时避免这些问题。复杂性是由两种东西导致的：依赖和模糊。这部分从高层次讨论了这些因素；余下的章节会讨论它们如何与低层次的设计决定相关。
从本书的目的来说，当一段代码无法单独被理解和修改时，就说明存在依赖；这段代码和其他代码以某种方式相关，如果这段代码修改了，也必须考虑和/或修改其他代码。在图 2.1(a) 的网站例子中，背景色创建了所有页面之间的依赖关系。所有页面必须有相同的背景，所以如果一个页面的背景修改了，那么所有其他的页面也必须修改。依赖的另外一个例子出现在网络协议中。一般来说，协议的发送方和接收方代码是独立的，但是它们都必须遵循这个协议；修改发送方的代码几乎总是要求接收方也做出相应修改，反过来也一样。方法的签名创建了这个方法的实现和调用者之间的依赖关系：如果这个方法新增了一个参数，这个方法的所有调用者都必须加以修改来指定这个参数。
依赖是软件中一个基础部分，不能被完全消除。实际上，在软件设计过程中我们会故意引入依赖。你每次新增类的时候，都会创建围绕这个类的 API 的依赖。然而，软件设计的目标之一是减少依赖，并且尽量保持依赖简单和明显。
考虑网站的例子。在每个页面中单独指定背景色的老网站中，所有的网页互相依赖。新网站通过在一个集中的地方指定背景色并提供 API 使得每个页面渲染时可以获取到颜色解决了这个问题。新网站消除了页面之间的依赖，但是创建了围绕获取背景色的 API 的新依赖。幸运的是，新依赖更明显了：每个网页依赖于 bannerBg 是很明显的，开发者可以很容易的找到所有使用这个变量的地方。更进一步的，编译器可以帮助管理 API 依赖：如果共享变量的名字变了，仍然使用原来名字的代码会报编译错误。新的网站用一个更简单更明显的依赖替换了原来不明显、难以管理的依赖。
复杂性的第二个原因是模糊。当重要信息不明显时，模糊就出现了。一个简单的例子是，变量名过于简单，无法携带很多有用信息（比如 时间）。或者，变量的文档可能没有它的单位，所以只能到使用这个变量的地方查看。当依赖的存在不明显时，模糊经常和依赖相关。比如，如果系统中要新增一个错误状态码，可能也需要在存储了每个状态码的文字消息的表中新增一条记录，但是对于看状态定义的程序员来说，消息表的存在可能不够明显。不一致也是模糊的一个重要来源：如果相同的变量名用于两种不同目的，对开发者来说，一个具体的变量服务于哪个目的就不明显了。</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第一章 介绍（一切都与复杂性有关）</title>
      <link>https://kyon.life/post/philosophy-of-software-design-1/</link>
      <pubDate>Wed, 19 Feb 2020 10:16:53 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-1/</guid>
      <description>编写软件是人类历史上最纯粹的创造性活动。程序员不受实践限制的约束，比如物理定律；我们可以创造有着现实世界中不可能存在的行为的令人兴奋的虚拟世界。编写程序不像芭蕾或篮球那样要求有很棒的身体技能或协调性。编写程序所需要的是创造性思维以及组织你的想法的能力。如果你可以想象出一个系统，那么你就有可能在电脑程序中把它实现出来。
这表明编写软件时最大的限制是对我们正在创造的系统的理解能力。随着一个程序不停演进并获得更多功能，它会变得复杂，组件之间会有不起眼的依赖。时间流逝，复杂度会累积，程序员在修改系统时，越来越难以把所有相关的因素都记在脑子里。这就会拖慢研发速度，并且导致 bug 产生，然后形成一个恶性循环。任何程序的复杂度都会不可避免的变高。越大型的程序，越多的人参与开发，就越难以控制复杂度。
好的开发工具可以帮助我们处理复杂度，过去的几十年中有许多很厉害的工具被创造了出来。但是仅仅使用这些工具，我们能做到的事情是有限制的。如果我们想要把编写软件变得简单，使得构建强大的系统变得更容易，我们必须找到使软件更简单的方式。尽管我们尽了最大的努力，复杂度还是会随着时间增长，但是更简单的设计允许我们在复杂度不可控之前构建出更大型更强大的系统。
控制复杂度有两种通用的方式，这本书都会讨论。第一种方式使通过使代码更简单更清晰来消除复杂度。比如，通过去除特殊场景或使用一致的标识可以减少复杂性。
第二种方式是封装复杂性，这样程序员可以在不完全了解它的复杂性的情况下基于这个系统进行开发。这种方式被称作 模块化设计。在模块化设计中，一个软件系统划分为不同的模块，比如面向对象语言中的类。模块被设计为相对独立的，这样程序员可以在不了解其他模块细节的情况下开发当前模块。
由于软件是如此具有延展性，所以软件设计是一个会横跨整个软件系统生命周期的持续的过程；这使得软件设计不同于物理系统比如建筑、轮船或桥梁的设计。然而，软件设计并不是一致被这样看待的。对于编程的历史上大多数时候，设计都集中于项目的开始阶段，就像其他工程原则一样。这种方式的极端被称为 瀑布模型，项目被划分为分散的阶段比如需求定义、设计、开发、测试和维护。在瀑布模型中，每个阶段都在下一个阶段开始前结束；大多数情况下，每个阶段是由不同的人来负责。整个系统在设计阶段一次性设计完成。这个阶段结束时设计就固定了，余下的阶段只是充实和设计这个设计。
不幸的是，瀑布模型对软件来说几乎无法奏效。软件系统本质上要比物理系统更复杂；对于大型软件系统来说，在没有搭建任何东西之前，不可能将设计考虑地足够全面。结果，最初的设计会有许多问题。在进行实现之前这些问题都不会明显地暴露出来。然而，这时瀑布模型无法应对重大设计的变更（比如，设计者已经调去其他项目）。因此，程序员会尝试在不改变整体设计的情况下修补问题。这会导致复杂度爆炸性增长。
由于这些问题的存在，当今的大多数软件开发项目采用一种增量的方式，比如 敏捷开发，最初的设计只关注总体功能的一小部分。这一部分被设计、实现，然后被评估。发现并更正原来设计中的问题，然后设计、实现和评估更多的功能。每次迭代都会暴露已有设计中的问题，并在设计下一部分的功能前修复。通过以这样的方式将设计扩散出去，最初设计中的问题可以在系统仍旧比较小型时修复；后面的功能可以从早期功能开发的经验中获益，所以出的问题会变少。
增量的方式对软件奏效是因为软件具有足够的延展性，允许在实现的过程中出现重大的设计变更。相反，对物理系统来说，重大的设计变更会更具有挑战性：比如，在建造过程中修改桥墩的数量是不切实际的。
增量研发意味着软件设计永远未完成。在系统的生命中设计持续存在：开发者应该一直考虑设计问题。增量研发也意味着持续的重新设计。系统或组件的初始设计几乎从来不是最好的；经验会不可避免地展示出完成这件事情的更好方式。作为一名软件开发者，应该始终寻找提升你正在开发的系统的设计的机会，而且应该为设计改进预留出一部分时间。
如果软件开发者应该使用考虑设计问题，并且降低复杂性是软件设计最重要的元素，那么软件开发者应该始终考虑复杂性。这本书就是关于如何使用复杂性指导软件设计的。
这本书有两个整体目标。第一个是描述软件复杂性的天性：“复杂性”意味着什么，为什么重要，以及如何识别出程序中存在不必要的复杂性？这本书第二个，而且更具挑战性的目标是给出在软件开发期间可以用来最小化复杂性的技术。不幸的是，并没有能够保证很棒的软件设计的简单的处方。相反，我会给出一系列哲学化的高层的概念，比如“类应该有深度” 或者 “通过定义使得错误不复存在”。这些概念可能无法立即区分出最好的设计，但是你可以使用它们比较不同的设计选择，并指导你在设计领域的探索。
1.1 如何使用这本书 这里讨论的设计原则很多都在一定程度上抽象，所以不看实际的代码可能会很难理解。寻找既足够小到可以放到书中又足够大到可以展示问题的例子非常困难（如果你遇到了好例子，请把它们发送给我）。所以，学习如何应用这些原则，只看这本书可能不够。
使用这本书最好的方式是和代码审查联合起来。当你阅读别人的代码时，考虑它是否遵循了这里讨论的概念，以及如何影响代码的复杂度。在别人的代码中更容易看到设计问题。你可以用本书中描述的红色警告来识别问题并且提出改进建议。审查代码也会使你接触到新的设计方式以及编程技巧。
提升你的设计技能的最好的方式之一是学习识别 红色警告：一段代码可能比它实际需要的更复杂的信号。在本书的课程中，我会指出和每个主要设计问题相关的表示问题出现的红色警告；最重要的几个在书的最后做了总结。当你编码时可以使用：当你看到一个红色警告，停止工作并寻找可以消除问题的其他设计。当你第一次尝试这种方式时，在找到可以消除红色警告的设计前，可能不得不尝试好几种设计。不要轻易放弃：在修复问题前尝试地越多，你学到的越多。随着时间流逝，你会发现代码中的红色警告越来越少，你的设计变得越来越简洁。你的经验也会向你展示其他红色警告，你可以用来识别设计问题（我会很乐意听到你新发现的这些红色警告）。
当应用本书中的理念时，应当注意节制和谨慎。每条规则都有例外，每个规范都有限制。如果你把每个设计理念都发挥到极致，可能最终会陷入困境。漂亮的设计反应了理念和实现之间较量的平衡。有几个章节中包含名为“过度实践”的部分，描述了如何发现你已经过度了。
这本书几乎所有例子都是 Java 或 C++ 的，大多数讨论都是针对面向对象语言中的设计类。然而，这些理念也可以很好的应用于其他领域。几乎所有和方法有关的理念也可以应用于没有面向对象功能的语言中的函数，比如 C。设计理念也可以应用于模块而不是类，比如子系统或网络服务。
有了这些基础以后，让我们更细致地讨论是什么导致了复杂性，以及如何使软件系统更简单。</description>
    </item>
    
    <item>
      <title>使线上 Spring 应用更好部署和调试</title>
      <link>https://kyon.life/post/spring-config/</link>
      <pubDate>Mon, 17 Feb 2020 21:32:03 +0800</pubDate>
      
      <guid>https://kyon.life/post/spring-config/</guid>
      <description>运行一个配置中心，可以方便快捷的更改线上服务多个实例的配置（通过 git commit&amp;amp;git push），配置中心通过服务发现暴露自己的 IP，client 中无需写死 server 地址，在 k8s 中部署也更自然。
运行一个可视化的应用详情 server，可以直观的看到应用健康监控、应用运行的包的构建时间及代码 commit id，应用当前生效的属性并可以动态修改，应用精确到类的日志级别，并可以动态修改。
要做到以上的事情，主要涉及四个组件的配置：
 spring-cloud-config spring-boot-admin spring-zookeeper-discovery spring-boot-actuator  效果展示 配置完成后效果图如下，主要是可视化的应用详情部分的展示，关于配置中心的使用方式的话，目前没有界面，主要就是对 spring-cloud-config server 后端数据的修改，然后 spring 有机制可以让它们动态生效，至少应用重启后可以覆盖 jar 包中的属性配置。
  一个美观页面，主要展示了三种信息：
 服务运行了多长时间 当前起的服务: configserver 和 cloud-adapter-aws，是从服务的 spring.application.name 取值 每个服务有几个实例，目前本地测试环境起的，都只有一个实例 服务的版本信息，从 pom.xml 文件种读的 &amp;lt;version&amp;gt;0.1.0&amp;lt;/version&amp;gt;   右上角切换到 Applications 的页面，以数字+列表形式展示了服务统计信息，当服务比较多的时候这个页面会更直观一些，另外当一个服务有多个实例时，可以从这个页面区分不同实例进入到详情页面。
 这里进入 cloud-adapter-aws 服务的一个实例页面，左侧导航栏有三部分，默认进入 Details 这一项。
页面上我会比较关注的部分，
 git 信息，包括 commit id，时间，分支 build 信息，包括版本号，构建时间，当线上出现问题时，可以通过 1，2 这两条信息快速定位到部署对应的包以及代码 健康状态监控，由 /actuator/health 返回的信息稍微规整了一下，可以快速看到依赖的第三方应用比如 mq、zk、db（如果使用了的话） 等组件的健康状态展示出来。另外也可以通过配置包含一些详细信息比如下面的 4 和 5 使用了 spring cloud discovery 的话，会把可以看到的 client 也展示出来 使用了 spring cloud config 的话，会把 config 加载的地址展示出来   这个页面展示了应用从各个地方加载的属性值，包括 application.</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第十一章 设计两次</title>
      <link>https://kyon.life/post/philosophy-of-software-design-11/</link>
      <pubDate>Fri, 14 Feb 2020 10:47:48 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-11/</guid>
      <description>设计软件是很难的，所以当你考虑如何构建一个模块或系统时，不太可能第一个想法就会产生最好的设计。如果对每个主要的设计决定都多考虑几个选项，会得到一个好得多的结果：设计两次。
假设你正在设计图形化文本编辑器中管理文本的类。第一步是定义这个类由编辑器中其他部分使用的的接口；与其使用第一个蹦到脑子里的主意，不如多考虑几种可能性。其中一个选择是面向行的接口，插入、修改和删除整行的文本。另外一个选择是基于单个字符的插入和删除接口。第三个选择是面向字符串的接口，对可能跨越行边界的任意范围的字符进行操作。不需要把每个选项的所有功能特性都确定下来；到目前为止，把几个重要的方法大概轮廓勾勒出来就足够了。
尝试选择和其他几种有本质区别的方式；这样你可以学到更多。即使你很确定只有一种合理的方式，也要考虑一下第二种设计方式，不管你认为它会有多糟糕。思考那个设计的弱点并且把它和其他设计的功能做对比是很有启发性的。
当你粗略地描绘出几种不同的设计后，列一个每个设计的优缺点的表格。最重要的考量是，这个接口对高层的软件来说是否易用。在上面的例子中，面向行和面向字符的接口都需要使用文本类的接口做额外的工作。使用面向行的接口时，当遇到部分或跨行的操作比如剪切和复制选区时，高层的软件需要拆分和合并行。使用面向字符的接口时，对于需要修改多个字符的操作需要循环实现。另外也需要考虑如下几种因素：
 其中一种选择比其他有着更简单的接口吗？在文本类的例子中，所有的文本接口都差不多简单。 其中一个接口比其他更通用吗？ 使用其中一个接口的实现会比其他更高效吗？在文本类的例子中，面向字符的接口很可能会比起另外的慢很多，因为它要求每一个字符都调用文本类一次  当你比较过几种不同的设计以后，你将可以更好地确定最佳设计。最好的选择可能是可选项中的一种，或者你可能发现可以把多个选项的功能组合成一个新的设计，会比原来的选择更好。
有时每个选择都不太好；当这种情况发生时，考虑一下能不能想到另外的方案。用你在原有选择中发现的问题来驱动新的设计。如果你正在设计文本类并且只想到了面向行和面向字符的这两种设计方式，你可能会注意到，这两种方式用起来都很别扭，因为它们要求高层软件做额外的文本操作。这是一个红色警告：如果需要有一个文本类，那么它应该处理所有和文本相关的操作。为了消除额外的文本操作，文本接口应该和高层软件中的操作更匹配。这些操作并不总是对应到单个字符或单行。这条推理应该引导你得到一个面向范围的 API，这会消除之前设计中的问题。
设计两次的原则可以应用在系统中的许多层级。对于模块来说，你可以先用这个原则来选择接口，像上面描述的那样。然后当你设计实现时可以再次应用这个原则：对于文本类来说，你可能考虑过各种实现比如行的链表，固定长度的字符块，或者“gap buffer”。设计实现时的目标和设计接口时并不一样：对于实现来说，最重要的是简洁和性能。在设计系统的高层时多探索几种可能性也是很有用的，比如当选择用户界面的功能时，或者将系统拆解为主要模块时。在每个例子中，如果能够比较几个不同的选择就可以更容易发现最好的方案。
设计两遍并不需要占用非常多额外的时间。对于一个小模块比如类来说，你可能都用不到一两个小时来考虑可选项。相比于在实现类时你需要花去好几天甚至好几个星期，这是非常少的时间了。最开始的设计实验很可能最终会有助于得到一个更好的设计，收益会远大于在设计两遍时花费的时间。对于更大的模块，最开始的设计探索会花费更多的时间，但是实现也会更慢，而且更好的设计的收益也会更高。
我注意到设计两遍的原则有时候对非常聪明的人来说很难接受。当他们成长时，聪明人发现他们关于任何问题的第一个快速的想法都足够好；没有必要再考虑第二种或者第三种可能。这就培养了一种糟糕的工作习惯。然而，当这些人更年长一些，他们不断提升进入有着越来越难的问题的环境中。最终，每个人都会到达第一个想法不够好的地步；如果你想要获得真正厉害的结果，就必须考虑第二种可能，或者可能是第三种，不管你有多聪明。大型软件系统的设计就属于这个分类：没有人可以第一次尝试就把它做对。
不幸的是，我经常看到坚持实现第一个想法的聪明人，这导致他们无法发挥真正的潜能（同时也使得和他们共事令人沮丧）。或许他们下意识地认为“聪明人可以第一次就做对”，所以如果他们尝试不同地设计就会表明他们其实并不聪明。不是这样的。不是你不聪明；而是问题真的很难！而且，这是一件好事：相比完全不用动脑的简单问题，解决需要仔细思考的难题要有趣得多。
设计两遍的方式不仅提高了你的设计，而且可以提高你设计的技能。设计和比较不同方式的过程会教给你影响设计好坏的因素。随着时间的推移，排除糟糕的设计并磨练真正厉害的设计对你来说会越来越容易。</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第十章 通过定义使得错误不复存在</title>
      <link>https://kyon.life/post/philosophy-of-software-design-10/</link>
      <pubDate>Mon, 10 Feb 2020 13:03:59 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-10/</guid>
      <description>异常处理是软件系统中最糟糕的复杂度来源。处理特殊条件的代码天生比处理正常情况的代码更难编写，而且开发者经常不管异常应该怎样处理就定义了它们。这章讨论了为什么异常对系统复杂度的影响不成比例的大，然后展示了如何简化异常处理。总体来说，本章关键的教训是减少必须处理异常的地方；在许多场景中，可以修改操作的语义，这样正常的操作就可以处理所有情况，因此就没有异常需要上报了（如本章标题）
10.1 为什么异常会增加复杂性 我用 异常 (exception) 这个术语来指代任何改变程序正常流程的特殊情况。许多编程语言都包含一套正式的异常处理机制，允许底层代码抛出异常由封装代码捕获。然而，在不使用正式的异常处理机制时也有可能发生异常，比如当方法返回一个特殊的值，表示它没有完成正常的行为。所有这些形式的异常都会影响到复杂度。
一段特定的代码会以几种不同的方式遇到异常：
 调用者可能会提供错误的参数或配置信息 被调用的函数可能无法完成被请求的操作。比如，I/O 可能会失败，或者请求的资源无法使用 在一个分布式系统中，网络数据包可能会丢失或延迟，服务器可能无法及时响应，或对端以一种无法预测的方式进行通信 代码可能会检测到 bug，内部不一致，或者其他它无法处理的情况  大型系统必须处理许多异常情况，尤其是如果它们还是分布式的或者需要容错的话。异常处理可能会占据整个系统代码的一大部分。
异常处理的代码天生比处理正常情况的代码更难编写。异常打断了代码正常的代码执行流程；而且通常意味着某些事情没有按预期进行。当异常发生时，程序可以通过两种方式处理它，每种方式都可能很复杂。第一种方式是不处理异常，继续前进完成进行中的工作。比如，如果出现了网络丢包，可以重新发送；如果数据损坏了，可以从冗余数据中恢复。第二种方式，中止当前的操作并上报异常。然而，中止操作可能会很复杂，因为异常发生时，系统可能处于不一致的状态（数据结构可能只被初始化了一部分）；异常处理代码必须恢复一致性，比如回滚所有异常发生前的改变。
更进一步地，异常处理代码可能会引入更多的异常。考虑重发网络丢包的情况。可能数据包实际上并没有丢，只是简单地延迟了。在这个情景中，重发的数据包会导致重复的数据包到达对端；这就引入了新的对端必须处理的异常情况。或者，考虑从冗余数据中恢复丢失数据的情况：如果冗余数据也丢失了呢？在恢复期间再次发生的异常通常比第一个异常更加微妙和复杂。如果通过中止处理中的操作来处理异常，那么必须作为另外一个异常上报给调用者。为了防止产生无尽的异常链，开发者最终必须找到一种不引入更多异常的方式来处理异常。
支持异常机制的语言通常是繁琐笨拙的，使得异常处理代码更加难以阅读。比如，参考下面的代码，使用 Java 的对象序列化和反序列化从一个文件中读出的推文：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  try (FileInputStream fileStream =new FileInputStream(fileName);BufferedInputStream bufferedStream =new BufferedInputStream(fileStream);ObjectInputStream objectStream =new ObjectInputStream(bufferedStream);) {for (int i = 0; i &amp;lt; tweetsPerFile; i++) {tweets.</description>
    </item>
    
    <item>
      <title>Philosophy of Software Design 第九章 - 合并还是拆分</title>
      <link>https://kyon.life/post/philosophy-of-software-design-9/</link>
      <pubDate>Thu, 06 Feb 2020 10:53:42 +0800</pubDate>
      
      <guid>https://kyon.life/post/philosophy-of-software-design-9/</guid>
      <description>软件设计中最基本的问题之一是：假定有两个不同的功能，应当在同一个地方实现它们，还是分开实现？这个问题存在于系统的各个层级：函数、方法、类和服务。比如，缓冲应该包含在提供基于流的文件 I/O 服务的类中，还是应该在单独的类中？HTTP 请求解析应该完全在同一个方法中实现，还是应该拆分到多个方法（甚至是多个类中）？这章讨论了做这些决定时需要考虑的因素。其中一些因素在前几章中已经讨论过，但是为了完整性，这里会再说一遍。
当决定应该合并还是拆开时，目标是降低整个系统的复杂度并提高它的模块化程度。看上去最好的办法是，将系统拆分成许多小组件：组件越小，每个组件就可能越简单。然而，过度拆分会增加额外的复杂度：
 一些复杂性来自于组件的数量：组件越多，跟踪它们就越困难，而且也更难定位某个组件。过度拆分通常会导致更多的接口，而每一个新接口都会增加复杂度。 过度拆分会需要额外的代码来管理组件。比如，一段代码使用一个对象，在拆分后变为多个，这段代码就不得不由管理单个对象变为管理多个。 过度拆分会创造割裂：过度拆分的组件会远比拆分前更分散。比如，拆分前方法本来在单个类中，拆分后可能会散布在多个类里，还可能会在不同的文件。这种割裂使得开发者难以同时看到整个组件，甚至意识不到它们的存在。如果组件真的独立，那分离开是没问题的：这使得开发者每次专注于一个组件，而不会被其他组件分神。另一方面，如果组件间有依赖，那分离就有问题了：开发者将不得不在组件之间来回跳转。更糟的是，他们可能都意识不到有依赖，从而导致 bug 的产生。 过度拆分可能会导致重复：原来在同一个实例中出现的代码，拆分后就需要出现在每个拆分过的组件中。  最好将将密切关联的不同代码片段组合到。但如果不同片段之间没有关系，它们最好分开。下面是一些两段代码之间有关联的迹象：
 它们共享信息；比如，这两段代码都依赖某种特殊类型文档的语法。 它们被同时使用：使用了其中一段代码很有可能也会使用另外一段。只有在这种关系是双向的时候才成立。举一个反例，磁盘缓存几乎总会用到哈希表，但是哈希表可以在很多无关磁盘缓存的场景中使用；因此，这两个模块应当分开。 它们的概念有重合，有一个简单的高层分类包括了这两段代码。比如，查询子串和大小写转换都属于字符串操作范畴；流控制和可靠传输都属于网络通信的范畴。 缺少其中一段代码时，另一段代码就会难以理解。  这章余下部分会用更具体的规则和例子来展示，什么时候将代码段放到一起，什么时候分开它们。
9.1 共享信息时合并 章节 5.4 以一个实现 HTTP 服务器的项目为例介绍了这条原则。在它的第一版实现中，读取和解析 HTTP 请求分别在两个类的两个方法中实现。第一个方法从网络 socket 读取收到的请求文本并把它放到一个 string 对象中。第二个方法解析 string 以获取请求的各个组成部分。使用这种分解方式，两个方法都需要知道大量关于 HTTP 请求格式的知识：第一个方法只是打算读取请求，不解析它，但是只有做了解析需要做的大部分工作才能识别请求体在哪里结束（举例来说，它必须解析请求头所有行才可以识别出包含总的请求体长度的那一行）。由于这种共享的信息，将读取和解析放在同一个地方更好；当把两个类合并成一个时，代码变得更短更简单。
9.2 可以简化接口时合并 当两个或更多个模块合并成一个模块时，为这个新模块定义一个比原来更简单和易用的接口成为可能。当原来的模块实现的是同一个问题的解决方案的不同部分时，这种情况可能会发生。在前一个部分中 HTTP 服务器的例子中，原始的方法的接口需要第一个方法返回 HTTP 请求的 string 并将它传递给第二个方法。当这两个方法合并后，这个接口可以删减掉。
而且，当两个或更多类被合并后，可能可以自动的执行某些功能，这样大多数使用者就不必知道它们的存在。Java 的 I/O 库展示了这种机会。如果 FileInputStream 和 BufferedInputStream 类合并并默认提供缓冲，绝大多数用户甚至不必知道缓冲的存在。合并后的 FileInputStream 类可以提供禁用或替换默认缓冲的机制，但是大多数用户不需要学习这些知识。
9.3 合并以删减重复 如果你发现相同模式的代码一再重复，找一找可以避免重复的代码。一种办法是将重复的代码重构到一个单独的方法中，并将重复代码片段替换为对这个方法的调用。当重复的代码片段很长而且替换方法的签名比较简单时，这种办法是最有效的。如果代码片段只有一两行，用方法调用替换可能带来不了什么收益。如果代码片段和它的上下文环境交互非常复杂（比如会读写大量的本地变量），那么替换方法可能需要一个复杂的签名（比如许多按引用传递的参数），这将降低它的价值。
  图 9.1：这段代码以几种不同方式处理接收到的网络包；对每一种类型，如果包长度对这种类型来说太短，就会打印一条消息。在这个版本的代码中，LOG 语句在几种不同的包类型中重复。
  另一种降低重复的办法是，重构代码使得有问题的代码只需要一个地方执行。假设你正在编写一个需要在几个地方返回错误的方法，而每个返回之前都需要执行相同的清理动作（见图 9.1）。如果你使用的编程语言支持 goto，你可以将清理代码放到方法的最后面，然后在每一处需要返回错误时使用 goto 进入。参见图 9.</description>
    </item>
    
  </channel>
</rss>