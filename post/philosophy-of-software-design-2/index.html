<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Philosophy of Software Design 第二章 复杂度的天性">
<meta itemprop="description" content="这本书是关于如何设计软件系统使得它们的复杂度最小化。第一步是了解敌人。到底什么是“复杂性”？你怎么知道一个系统是不必要的复杂？什么会导致系统变复杂？这章会在较高层级解决这些问题；余下的章节会就具体结构特征向你展示如何在较低层级识别复杂度。
识别复杂性是设计技能中一项关键的能力。它使得你可以在投入大量精力前发现问题，并且在许多可选项中做出好选择。分辨出一个设计是否简洁要比创造一个简洁的设计容易，但是一旦你可以识别出一个系统过于复杂，你就可以使用这个能力来指导你的设计哲学向着简单性出发。如果一个设计看上去很复杂，尝试一种不同的方式然后看看是否变简单了。随着时间流逝，你会注意到一些特定的技术会得到更简单的设计，另外一些则和复杂性相关。这将使得你能更快地产出更简洁的设计。
本章也会给出一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节会使用本章的材料来评判各种不同的改善方法和结论。
2.1 定义复杂性 为了这本书的目的，我以一种实践方式定义“复杂性”。复杂性是和软件系统结构相关的、使得理解和修改系统更困难的任何东西。 复杂性可能会以很多形式出现。比如，可能难以理解一段代码是如何运行的；可能一点小的改进需要花费很大精力，或者为了做出改进需要修改系统的哪些部分难以确定；可能很难在不引入其他问题的情况下修复一个 bug。如果很难理解和修改一个软件系统，那么它就是复杂的；如果很容易理解和修改，那它就是简单的。
也可以从成本和收益的角度考虑复杂性。在复杂系统中，哪怕是实现一个很小的改进都需要花费很多工作。在简单系统中，可以用更少的工作完成更大的改进。
复杂性是开发者在尝试完成一个特定目标时在特定时间点的经历。并不一定和系统整体的大小或功能相关。人们经常用“复杂（complex）”一词来描述有着复杂（sophisticated）功能的大型系统，但是如果这样的系统开发很容易上手的话，那么，从本书的角度来看，并不复杂（complex）。当然，几乎所有大型和复杂（sophisticated）的软件系统实际上也难以开发，所以它们也符合我这里复杂的定义。但是这并不一定是事实。小型并不复杂（unsophisticated）的系统也有可能非常复杂（complex）。1
复杂性由最常见的活动决定。如果系统中包括一些非常复杂的部分，但是这些基本不会用到，那它们对系统整体的复杂性几乎没影响。用粗略的数学方式来表示：
$C = ∑c_pt_p$
系统整体复杂性（C）由每部分的复杂性 （$c_p$）加权开发者在这部分花费的时间（$t_p$）决定。把复杂性隔离在一个从不会被看到的地方基本就和完全消除了复杂性一样。
相较于编写者，复杂性对阅读者来说更明显。如果你编写了一段对你来说似乎很简单的代码，但是其他人认为它复杂，那么它就是复杂的。当你发现你处于这样的境况中，请其他开发者来看一下为什么他们觉得代码很复杂就很值得一试；在你和他们不同的观点中很有可能学到有趣的东西。作为开发者的工作不仅仅是写出你觉得容易的代码，也要让其他人觉得容易。
2.2 复杂性的征兆 复杂性通过三种一般的方式表现出来，下面的段落将会描述到。每一种都会使得完成研发任务变得困难。
 图2.1： 网站的每个页面都会展示有颜色的横幅。(a) 中横幅的背景色是在每个页面中显示指定的。(b) 中共享变量保存背景色的值，每个页面都指向这个变量。(c) 中一些页面会展示额外的颜色表示强调，这个颜色是背景色带阴影的较暗的转换；如果背景色变化了，强调色也必须跟着变化。
  放大改变： 复杂性的第一个征兆是，一个看上去简单的改变需要在许多不同的地方修改代码。比如，考虑有着不同页面的网站，每一个页面都会展示有着背景色的横幅。在很多早期网站中，颜色是由每个页面显示地指定的，如图 2.1(a)。为了改变这个网站的背景色，开发者可能需要手动地修改每个已有页面；对于有着上千张页面的大型网站来说这几乎是不可能的。幸运的是，现代的网站使用了图 2.1(b) 中的方式，横幅颜色在一个集中的地方一次性指定，所有页面都指向这个共享的值。使用这种方式时，整个网站的横幅颜色变化可以由单个修改完成。好的设计的目标之一是，减少每个设计决定会影响到的代码数量，这样修改设计时不需要改动很多代码。
心智负担： 复杂性第二个征兆是心智负担，心智负担是指开发者为了完成任务需要了解多少东西。更高的心智负担意味着开发者不得不花费更多时间学习必需了解的信息，而且可能会由于他们遗漏了一些重要信息而增加出现 bug 的风险。比如，C 中分配内存的函数返回指向内存的指针，并且假设调用者会释放内存。这增加了使用这个函数的开发者的心智负担；如果开发者没能释放内存，那么就会出现内存泄漏。如果可以重构系统使得开发者无需关心内存释放（分配内存的模块同时负责释放它），就可以降低心智负担。心智负担以多种方式出现，比如有许多方法的 API，全局变量，不一致性，模块间依赖。
系统设计者有时候认为可以用代码行数衡量复杂性。他们认为如果一个实现比另外的短，那么肯定就更简单；如果只需要很少几行就可以做出改变，那这个改变肯定很容易。然而，这个视角忽略了和心智负担有关的成本。我曾经见过只需要几行就可以完成一个应用的框架，但是想要搞懂这几行做了什么事情却及其困难。有时候需要更多行代码的方式其实更简单，因为它降低了心智负担。
未知的未知： 复杂性的第三个征兆是，为了完成任务需要修改哪些代码或者开发者需要了解哪些信息并不明显。图 2.1(c) 展示了这个问题。网站使用集中变量来决定横幅背景色，所以看上去很容易修改。然而，一些网页使用了带阴影加深的背景色来表示强调，而这个加深的颜色是在每个页面单独指定的。如果背景色变化了，那强调色也必须相匹配地跟着变化。不幸的是，开发者不太可能意识到这个颜色的存在，所以他们可能修改了集中变量 bannerBg 但是没有更新强调色。即使开发者意识到了这个问题，哪些页面使用了强调色也不明显，所以开发者不得不搜索网站中的所有页面。
复杂性的三种表现方式中，未知的未知是最糟糕的。未知的未知意味着你需要了解一些东西，但是你却无法知道需要了解什么，或者甚至这些东西是否存在。在你修改后，直到出现 bug 之前都无法知道。改变放大很烦人，但是只要知道需要修改哪些代码，一旦完成修改系统还是可以工作。类似的，高的心智负担会增加做出改变的成本，但是如果知道哪些信息需要掌握，改变仍旧很可能是正确的。而未知的未知的情况，你将不知道需要做什么，或者提议的方案是否可以工作。唯一可以确定的方式，是阅读系统的每一行代码，这对任何规模的系统都是不切实际的。即使这样也还不够，因为修改可能依赖于一个从未记录的微小的设计决定。
对于系统来说，好设计的最重要的目标之一是使系统变得浅显易懂。这是高心智负担和未知的未知的对立面。在浅显易懂的系统中，开发者可以快速了解已有代码是如何工作的以及做出修改需要什么。浅显易懂的系统中，开发者可以快速的猜出要做什么，不需要非常认真地思考，而且还可以对猜测很有信心。第十八章讨论了使得代码更浅显易懂的技术。
2.3 复杂性的原因 既然你已经知道了复杂性的高层级的征兆，还有为什么复杂性会使得软件开发变困难，下一步就是搞懂什么导致了复杂性，这样我们就可以在设计系统时避免这些问题。复杂性是由两种东西导致的：依赖和模糊。这部分从高层次讨论了这些因素；余下的章节会讨论它们如何与低层次的设计决定相关。
从本书的目的来说，当一段代码无法单独被理解和修改时，就说明存在依赖；这段代码和其他代码以某种方式相关，如果这段代码修改了，也必须考虑和/或修改其他代码。在图 2.1(a) 的网站例子中，背景色创建了所有页面之间的依赖关系。所有页面必须有相同的背景，所以如果一个页面的背景修改了，那么所有其他的页面也必须修改。依赖的另外一个例子出现在网络协议中。一般来说，协议的发送方和接收方代码是独立的，但是它们都必须遵循这个协议；修改发送方的代码几乎总是要求接收方也做出相应修改，反过来也一样。方法的签名创建了这个方法的实现和调用者之间的依赖关系：如果这个方法新增了一个参数，这个方法的所有调用者都必须加以修改来指定这个参数。
依赖是软件中一个基础部分，不能被完全消除。实际上，在软件设计过程中我们会故意引入依赖。你每次新增类的时候，都会创建围绕这个类的 API 的依赖。然而，软件设计的目标之一是减少依赖，并且尽量保持依赖简单和明显。
考虑网站的例子。在每个页面中单独指定背景色的老网站中，所有的网页互相依赖。新网站通过在一个集中的地方指定背景色并提供 API 使得每个页面渲染时可以获取到颜色解决了这个问题。新网站消除了页面之间的依赖，但是创建了围绕获取背景色的 API 的新依赖。幸运的是，新依赖更明显了：每个网页依赖于 bannerBg 是很明显的，开发者可以很容易的找到所有使用这个变量的地方。更进一步的，编译器可以帮助管理 API 依赖：如果共享变量的名字变了，仍然使用原来名字的代码会报编译错误。新的网站用一个更简单更明显的依赖替换了原来不明显、难以管理的依赖。
复杂性的第二个原因是模糊。当重要信息不明显时，模糊就出现了。一个简单的例子是，变量名过于简单，无法携带很多有用信息（比如 时间）。或者，变量的文档可能没有它的单位，所以只能到使用这个变量的地方查看。当依赖的存在不明显时，模糊经常和依赖相关。比如，如果系统中要新增一个错误状态码，可能也需要在存储了每个状态码的文字消息的表中新增一条记录，但是对于看状态定义的程序员来说，消息表的存在可能不够明显。不一致也是模糊的一个重要来源：如果相同的变量名用于两种不同目的，对开发者来说，一个具体的变量服务于哪个目的就不明显了。">
<meta itemprop="datePublished" content="2020-02-19T12:15:39&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-21T17:13:32&#43;08:00" />
<meta itemprop="wordCount" content="83">



<meta itemprop="keywords" content="鹦鹉学舌,学习笔记," /><meta property="og:title" content="Philosophy of Software Design 第二章 复杂度的天性" />
<meta property="og:description" content="这本书是关于如何设计软件系统使得它们的复杂度最小化。第一步是了解敌人。到底什么是“复杂性”？你怎么知道一个系统是不必要的复杂？什么会导致系统变复杂？这章会在较高层级解决这些问题；余下的章节会就具体结构特征向你展示如何在较低层级识别复杂度。
识别复杂性是设计技能中一项关键的能力。它使得你可以在投入大量精力前发现问题，并且在许多可选项中做出好选择。分辨出一个设计是否简洁要比创造一个简洁的设计容易，但是一旦你可以识别出一个系统过于复杂，你就可以使用这个能力来指导你的设计哲学向着简单性出发。如果一个设计看上去很复杂，尝试一种不同的方式然后看看是否变简单了。随着时间流逝，你会注意到一些特定的技术会得到更简单的设计，另外一些则和复杂性相关。这将使得你能更快地产出更简洁的设计。
本章也会给出一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节会使用本章的材料来评判各种不同的改善方法和结论。
2.1 定义复杂性 为了这本书的目的，我以一种实践方式定义“复杂性”。复杂性是和软件系统结构相关的、使得理解和修改系统更困难的任何东西。 复杂性可能会以很多形式出现。比如，可能难以理解一段代码是如何运行的；可能一点小的改进需要花费很大精力，或者为了做出改进需要修改系统的哪些部分难以确定；可能很难在不引入其他问题的情况下修复一个 bug。如果很难理解和修改一个软件系统，那么它就是复杂的；如果很容易理解和修改，那它就是简单的。
也可以从成本和收益的角度考虑复杂性。在复杂系统中，哪怕是实现一个很小的改进都需要花费很多工作。在简单系统中，可以用更少的工作完成更大的改进。
复杂性是开发者在尝试完成一个特定目标时在特定时间点的经历。并不一定和系统整体的大小或功能相关。人们经常用“复杂（complex）”一词来描述有着复杂（sophisticated）功能的大型系统，但是如果这样的系统开发很容易上手的话，那么，从本书的角度来看，并不复杂（complex）。当然，几乎所有大型和复杂（sophisticated）的软件系统实际上也难以开发，所以它们也符合我这里复杂的定义。但是这并不一定是事实。小型并不复杂（unsophisticated）的系统也有可能非常复杂（complex）。1
复杂性由最常见的活动决定。如果系统中包括一些非常复杂的部分，但是这些基本不会用到，那它们对系统整体的复杂性几乎没影响。用粗略的数学方式来表示：
$C = ∑c_pt_p$
系统整体复杂性（C）由每部分的复杂性 （$c_p$）加权开发者在这部分花费的时间（$t_p$）决定。把复杂性隔离在一个从不会被看到的地方基本就和完全消除了复杂性一样。
相较于编写者，复杂性对阅读者来说更明显。如果你编写了一段对你来说似乎很简单的代码，但是其他人认为它复杂，那么它就是复杂的。当你发现你处于这样的境况中，请其他开发者来看一下为什么他们觉得代码很复杂就很值得一试；在你和他们不同的观点中很有可能学到有趣的东西。作为开发者的工作不仅仅是写出你觉得容易的代码，也要让其他人觉得容易。
2.2 复杂性的征兆 复杂性通过三种一般的方式表现出来，下面的段落将会描述到。每一种都会使得完成研发任务变得困难。
 图2.1： 网站的每个页面都会展示有颜色的横幅。(a) 中横幅的背景色是在每个页面中显示指定的。(b) 中共享变量保存背景色的值，每个页面都指向这个变量。(c) 中一些页面会展示额外的颜色表示强调，这个颜色是背景色带阴影的较暗的转换；如果背景色变化了，强调色也必须跟着变化。
  放大改变： 复杂性的第一个征兆是，一个看上去简单的改变需要在许多不同的地方修改代码。比如，考虑有着不同页面的网站，每一个页面都会展示有着背景色的横幅。在很多早期网站中，颜色是由每个页面显示地指定的，如图 2.1(a)。为了改变这个网站的背景色，开发者可能需要手动地修改每个已有页面；对于有着上千张页面的大型网站来说这几乎是不可能的。幸运的是，现代的网站使用了图 2.1(b) 中的方式，横幅颜色在一个集中的地方一次性指定，所有页面都指向这个共享的值。使用这种方式时，整个网站的横幅颜色变化可以由单个修改完成。好的设计的目标之一是，减少每个设计决定会影响到的代码数量，这样修改设计时不需要改动很多代码。
心智负担： 复杂性第二个征兆是心智负担，心智负担是指开发者为了完成任务需要了解多少东西。更高的心智负担意味着开发者不得不花费更多时间学习必需了解的信息，而且可能会由于他们遗漏了一些重要信息而增加出现 bug 的风险。比如，C 中分配内存的函数返回指向内存的指针，并且假设调用者会释放内存。这增加了使用这个函数的开发者的心智负担；如果开发者没能释放内存，那么就会出现内存泄漏。如果可以重构系统使得开发者无需关心内存释放（分配内存的模块同时负责释放它），就可以降低心智负担。心智负担以多种方式出现，比如有许多方法的 API，全局变量，不一致性，模块间依赖。
系统设计者有时候认为可以用代码行数衡量复杂性。他们认为如果一个实现比另外的短，那么肯定就更简单；如果只需要很少几行就可以做出改变，那这个改变肯定很容易。然而，这个视角忽略了和心智负担有关的成本。我曾经见过只需要几行就可以完成一个应用的框架，但是想要搞懂这几行做了什么事情却及其困难。有时候需要更多行代码的方式其实更简单，因为它降低了心智负担。
未知的未知： 复杂性的第三个征兆是，为了完成任务需要修改哪些代码或者开发者需要了解哪些信息并不明显。图 2.1(c) 展示了这个问题。网站使用集中变量来决定横幅背景色，所以看上去很容易修改。然而，一些网页使用了带阴影加深的背景色来表示强调，而这个加深的颜色是在每个页面单独指定的。如果背景色变化了，那强调色也必须相匹配地跟着变化。不幸的是，开发者不太可能意识到这个颜色的存在，所以他们可能修改了集中变量 bannerBg 但是没有更新强调色。即使开发者意识到了这个问题，哪些页面使用了强调色也不明显，所以开发者不得不搜索网站中的所有页面。
复杂性的三种表现方式中，未知的未知是最糟糕的。未知的未知意味着你需要了解一些东西，但是你却无法知道需要了解什么，或者甚至这些东西是否存在。在你修改后，直到出现 bug 之前都无法知道。改变放大很烦人，但是只要知道需要修改哪些代码，一旦完成修改系统还是可以工作。类似的，高的心智负担会增加做出改变的成本，但是如果知道哪些信息需要掌握，改变仍旧很可能是正确的。而未知的未知的情况，你将不知道需要做什么，或者提议的方案是否可以工作。唯一可以确定的方式，是阅读系统的每一行代码，这对任何规模的系统都是不切实际的。即使这样也还不够，因为修改可能依赖于一个从未记录的微小的设计决定。
对于系统来说，好设计的最重要的目标之一是使系统变得浅显易懂。这是高心智负担和未知的未知的对立面。在浅显易懂的系统中，开发者可以快速了解已有代码是如何工作的以及做出修改需要什么。浅显易懂的系统中，开发者可以快速的猜出要做什么，不需要非常认真地思考，而且还可以对猜测很有信心。第十八章讨论了使得代码更浅显易懂的技术。
2.3 复杂性的原因 既然你已经知道了复杂性的高层级的征兆，还有为什么复杂性会使得软件开发变困难，下一步就是搞懂什么导致了复杂性，这样我们就可以在设计系统时避免这些问题。复杂性是由两种东西导致的：依赖和模糊。这部分从高层次讨论了这些因素；余下的章节会讨论它们如何与低层次的设计决定相关。
从本书的目的来说，当一段代码无法单独被理解和修改时，就说明存在依赖；这段代码和其他代码以某种方式相关，如果这段代码修改了，也必须考虑和/或修改其他代码。在图 2.1(a) 的网站例子中，背景色创建了所有页面之间的依赖关系。所有页面必须有相同的背景，所以如果一个页面的背景修改了，那么所有其他的页面也必须修改。依赖的另外一个例子出现在网络协议中。一般来说，协议的发送方和接收方代码是独立的，但是它们都必须遵循这个协议；修改发送方的代码几乎总是要求接收方也做出相应修改，反过来也一样。方法的签名创建了这个方法的实现和调用者之间的依赖关系：如果这个方法新增了一个参数，这个方法的所有调用者都必须加以修改来指定这个参数。
依赖是软件中一个基础部分，不能被完全消除。实际上，在软件设计过程中我们会故意引入依赖。你每次新增类的时候，都会创建围绕这个类的 API 的依赖。然而，软件设计的目标之一是减少依赖，并且尽量保持依赖简单和明显。
考虑网站的例子。在每个页面中单独指定背景色的老网站中，所有的网页互相依赖。新网站通过在一个集中的地方指定背景色并提供 API 使得每个页面渲染时可以获取到颜色解决了这个问题。新网站消除了页面之间的依赖，但是创建了围绕获取背景色的 API 的新依赖。幸运的是，新依赖更明显了：每个网页依赖于 bannerBg 是很明显的，开发者可以很容易的找到所有使用这个变量的地方。更进一步的，编译器可以帮助管理 API 依赖：如果共享变量的名字变了，仍然使用原来名字的代码会报编译错误。新的网站用一个更简单更明显的依赖替换了原来不明显、难以管理的依赖。
复杂性的第二个原因是模糊。当重要信息不明显时，模糊就出现了。一个简单的例子是，变量名过于简单，无法携带很多有用信息（比如 时间）。或者，变量的文档可能没有它的单位，所以只能到使用这个变量的地方查看。当依赖的存在不明显时，模糊经常和依赖相关。比如，如果系统中要新增一个错误状态码，可能也需要在存储了每个状态码的文字消息的表中新增一条记录，但是对于看状态定义的程序员来说，消息表的存在可能不够明显。不一致也是模糊的一个重要来源：如果相同的变量名用于两种不同目的，对开发者来说，一个具体的变量服务于哪个目的就不明显了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kyon.life/post/philosophy-of-software-design-2/" />
<meta property="article:published_time" content="2020-02-19T12:15:39+08:00" />
<meta property="article:modified_time" content="2020-02-21T17:13:32+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Philosophy of Software Design 第二章 复杂度的天性"/>
<meta name="twitter:description" content="这本书是关于如何设计软件系统使得它们的复杂度最小化。第一步是了解敌人。到底什么是“复杂性”？你怎么知道一个系统是不必要的复杂？什么会导致系统变复杂？这章会在较高层级解决这些问题；余下的章节会就具体结构特征向你展示如何在较低层级识别复杂度。
识别复杂性是设计技能中一项关键的能力。它使得你可以在投入大量精力前发现问题，并且在许多可选项中做出好选择。分辨出一个设计是否简洁要比创造一个简洁的设计容易，但是一旦你可以识别出一个系统过于复杂，你就可以使用这个能力来指导你的设计哲学向着简单性出发。如果一个设计看上去很复杂，尝试一种不同的方式然后看看是否变简单了。随着时间流逝，你会注意到一些特定的技术会得到更简单的设计，另外一些则和复杂性相关。这将使得你能更快地产出更简洁的设计。
本章也会给出一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节会使用本章的材料来评判各种不同的改善方法和结论。
2.1 定义复杂性 为了这本书的目的，我以一种实践方式定义“复杂性”。复杂性是和软件系统结构相关的、使得理解和修改系统更困难的任何东西。 复杂性可能会以很多形式出现。比如，可能难以理解一段代码是如何运行的；可能一点小的改进需要花费很大精力，或者为了做出改进需要修改系统的哪些部分难以确定；可能很难在不引入其他问题的情况下修复一个 bug。如果很难理解和修改一个软件系统，那么它就是复杂的；如果很容易理解和修改，那它就是简单的。
也可以从成本和收益的角度考虑复杂性。在复杂系统中，哪怕是实现一个很小的改进都需要花费很多工作。在简单系统中，可以用更少的工作完成更大的改进。
复杂性是开发者在尝试完成一个特定目标时在特定时间点的经历。并不一定和系统整体的大小或功能相关。人们经常用“复杂（complex）”一词来描述有着复杂（sophisticated）功能的大型系统，但是如果这样的系统开发很容易上手的话，那么，从本书的角度来看，并不复杂（complex）。当然，几乎所有大型和复杂（sophisticated）的软件系统实际上也难以开发，所以它们也符合我这里复杂的定义。但是这并不一定是事实。小型并不复杂（unsophisticated）的系统也有可能非常复杂（complex）。1
复杂性由最常见的活动决定。如果系统中包括一些非常复杂的部分，但是这些基本不会用到，那它们对系统整体的复杂性几乎没影响。用粗略的数学方式来表示：
$C = ∑c_pt_p$
系统整体复杂性（C）由每部分的复杂性 （$c_p$）加权开发者在这部分花费的时间（$t_p$）决定。把复杂性隔离在一个从不会被看到的地方基本就和完全消除了复杂性一样。
相较于编写者，复杂性对阅读者来说更明显。如果你编写了一段对你来说似乎很简单的代码，但是其他人认为它复杂，那么它就是复杂的。当你发现你处于这样的境况中，请其他开发者来看一下为什么他们觉得代码很复杂就很值得一试；在你和他们不同的观点中很有可能学到有趣的东西。作为开发者的工作不仅仅是写出你觉得容易的代码，也要让其他人觉得容易。
2.2 复杂性的征兆 复杂性通过三种一般的方式表现出来，下面的段落将会描述到。每一种都会使得完成研发任务变得困难。
 图2.1： 网站的每个页面都会展示有颜色的横幅。(a) 中横幅的背景色是在每个页面中显示指定的。(b) 中共享变量保存背景色的值，每个页面都指向这个变量。(c) 中一些页面会展示额外的颜色表示强调，这个颜色是背景色带阴影的较暗的转换；如果背景色变化了，强调色也必须跟着变化。
  放大改变： 复杂性的第一个征兆是，一个看上去简单的改变需要在许多不同的地方修改代码。比如，考虑有着不同页面的网站，每一个页面都会展示有着背景色的横幅。在很多早期网站中，颜色是由每个页面显示地指定的，如图 2.1(a)。为了改变这个网站的背景色，开发者可能需要手动地修改每个已有页面；对于有着上千张页面的大型网站来说这几乎是不可能的。幸运的是，现代的网站使用了图 2.1(b) 中的方式，横幅颜色在一个集中的地方一次性指定，所有页面都指向这个共享的值。使用这种方式时，整个网站的横幅颜色变化可以由单个修改完成。好的设计的目标之一是，减少每个设计决定会影响到的代码数量，这样修改设计时不需要改动很多代码。
心智负担： 复杂性第二个征兆是心智负担，心智负担是指开发者为了完成任务需要了解多少东西。更高的心智负担意味着开发者不得不花费更多时间学习必需了解的信息，而且可能会由于他们遗漏了一些重要信息而增加出现 bug 的风险。比如，C 中分配内存的函数返回指向内存的指针，并且假设调用者会释放内存。这增加了使用这个函数的开发者的心智负担；如果开发者没能释放内存，那么就会出现内存泄漏。如果可以重构系统使得开发者无需关心内存释放（分配内存的模块同时负责释放它），就可以降低心智负担。心智负担以多种方式出现，比如有许多方法的 API，全局变量，不一致性，模块间依赖。
系统设计者有时候认为可以用代码行数衡量复杂性。他们认为如果一个实现比另外的短，那么肯定就更简单；如果只需要很少几行就可以做出改变，那这个改变肯定很容易。然而，这个视角忽略了和心智负担有关的成本。我曾经见过只需要几行就可以完成一个应用的框架，但是想要搞懂这几行做了什么事情却及其困难。有时候需要更多行代码的方式其实更简单，因为它降低了心智负担。
未知的未知： 复杂性的第三个征兆是，为了完成任务需要修改哪些代码或者开发者需要了解哪些信息并不明显。图 2.1(c) 展示了这个问题。网站使用集中变量来决定横幅背景色，所以看上去很容易修改。然而，一些网页使用了带阴影加深的背景色来表示强调，而这个加深的颜色是在每个页面单独指定的。如果背景色变化了，那强调色也必须相匹配地跟着变化。不幸的是，开发者不太可能意识到这个颜色的存在，所以他们可能修改了集中变量 bannerBg 但是没有更新强调色。即使开发者意识到了这个问题，哪些页面使用了强调色也不明显，所以开发者不得不搜索网站中的所有页面。
复杂性的三种表现方式中，未知的未知是最糟糕的。未知的未知意味着你需要了解一些东西，但是你却无法知道需要了解什么，或者甚至这些东西是否存在。在你修改后，直到出现 bug 之前都无法知道。改变放大很烦人，但是只要知道需要修改哪些代码，一旦完成修改系统还是可以工作。类似的，高的心智负担会增加做出改变的成本，但是如果知道哪些信息需要掌握，改变仍旧很可能是正确的。而未知的未知的情况，你将不知道需要做什么，或者提议的方案是否可以工作。唯一可以确定的方式，是阅读系统的每一行代码，这对任何规模的系统都是不切实际的。即使这样也还不够，因为修改可能依赖于一个从未记录的微小的设计决定。
对于系统来说，好设计的最重要的目标之一是使系统变得浅显易懂。这是高心智负担和未知的未知的对立面。在浅显易懂的系统中，开发者可以快速了解已有代码是如何工作的以及做出修改需要什么。浅显易懂的系统中，开发者可以快速的猜出要做什么，不需要非常认真地思考，而且还可以对猜测很有信心。第十八章讨论了使得代码更浅显易懂的技术。
2.3 复杂性的原因 既然你已经知道了复杂性的高层级的征兆，还有为什么复杂性会使得软件开发变困难，下一步就是搞懂什么导致了复杂性，这样我们就可以在设计系统时避免这些问题。复杂性是由两种东西导致的：依赖和模糊。这部分从高层次讨论了这些因素；余下的章节会讨论它们如何与低层次的设计决定相关。
从本书的目的来说，当一段代码无法单独被理解和修改时，就说明存在依赖；这段代码和其他代码以某种方式相关，如果这段代码修改了，也必须考虑和/或修改其他代码。在图 2.1(a) 的网站例子中，背景色创建了所有页面之间的依赖关系。所有页面必须有相同的背景，所以如果一个页面的背景修改了，那么所有其他的页面也必须修改。依赖的另外一个例子出现在网络协议中。一般来说，协议的发送方和接收方代码是独立的，但是它们都必须遵循这个协议；修改发送方的代码几乎总是要求接收方也做出相应修改，反过来也一样。方法的签名创建了这个方法的实现和调用者之间的依赖关系：如果这个方法新增了一个参数，这个方法的所有调用者都必须加以修改来指定这个参数。
依赖是软件中一个基础部分，不能被完全消除。实际上，在软件设计过程中我们会故意引入依赖。你每次新增类的时候，都会创建围绕这个类的 API 的依赖。然而，软件设计的目标之一是减少依赖，并且尽量保持依赖简单和明显。
考虑网站的例子。在每个页面中单独指定背景色的老网站中，所有的网页互相依赖。新网站通过在一个集中的地方指定背景色并提供 API 使得每个页面渲染时可以获取到颜色解决了这个问题。新网站消除了页面之间的依赖，但是创建了围绕获取背景色的 API 的新依赖。幸运的是，新依赖更明显了：每个网页依赖于 bannerBg 是很明显的，开发者可以很容易的找到所有使用这个变量的地方。更进一步的，编译器可以帮助管理 API 依赖：如果共享变量的名字变了，仍然使用原来名字的代码会报编译错误。新的网站用一个更简单更明显的依赖替换了原来不明显、难以管理的依赖。
复杂性的第二个原因是模糊。当重要信息不明显时，模糊就出现了。一个简单的例子是，变量名过于简单，无法携带很多有用信息（比如 时间）。或者，变量的文档可能没有它的单位，所以只能到使用这个变量的地方查看。当依赖的存在不明显时，模糊经常和依赖相关。比如，如果系统中要新增一个错误状态码，可能也需要在存储了每个状态码的文字消息的表中新增一条记录，但是对于看状态定义的程序员来说，消息表的存在可能不够明显。不一致也是模糊的一个重要来源：如果相同的变量名用于两种不同目的，对开发者来说，一个具体的变量服务于哪个目的就不明显了。"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Philosophy of Software Design 第二章 复杂度的天性</title>
	<link rel="stylesheet" href="https://kyon.life/css/style.min.443b23788332c9ab69f53339ca18681191755ec4a88ae2a7cdd34c3a1d542188.css" integrity="sha256-RDsjeIMyyatp9TM5yhhoEZF1XsSoiuKnzdNMOh1UIYg=" crossorigin="anonymous">
	
	<link rel="stylesheet" href="https://kyon.life/css/share.min.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://kyon.life/">kyon&#39;s wonderland with ❤️</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://kyon.life/post/">博文</a>
				<a href="https://kyon.life/about/">关于</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title="目录"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="https://instagram.com/kyon_wy" target="_blank" rel="noopener me" title="Instagram"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"></line></svg></a><a href="https://github.com/kyon0304" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="菜单"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://kyon.life/post/">博文</a></li>
			<li><a href="https://kyon.life/about/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>2 月 19 号, 2020</span></div>
				<h1>Philosophy of Software Design 第二章 复杂度的天性</h1>
			</header>
			<div class="content">
				<p>这本书是关于如何设计软件系统使得它们的复杂度最小化。第一步是了解敌人。到底什么是“复杂性”？你怎么知道一个系统是不必要的复杂？什么会导致系统变复杂？这章会在较高层级解决这些问题；余下的章节会就具体结构特征向你展示如何在较低层级识别复杂度。</p>
<p>识别复杂性是设计技能中一项关键的能力。它使得你可以在投入大量精力前发现问题，并且在许多可选项中做出好选择。分辨出一个设计是否简洁要比创造一个简洁的设计容易，但是一旦你可以识别出一个系统过于复杂，你就可以使用这个能力来指导你的设计哲学向着简单性出发。如果一个设计看上去很复杂，尝试一种不同的方式然后看看是否变简单了。随着时间流逝，你会注意到一些特定的技术会得到更简单的设计，另外一些则和复杂性相关。这将使得你能更快地产出更简洁的设计。</p>
<p>本章也会给出一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节会使用本章的材料来评判各种不同的改善方法和结论。</p>
<h2 id="21-定义复杂性">2.1 定义复杂性<a href="#21-定义复杂性" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>为了这本书的目的，我以一种实践方式定义“复杂性”。<strong>复杂性是和软件系统结构相关的、使得理解和修改系统更困难的任何东西。</strong> 复杂性可能会以很多形式出现。比如，可能难以理解一段代码是如何运行的；可能一点小的改进需要花费很大精力，或者为了做出改进需要修改系统的哪些部分难以确定；可能很难在不引入其他问题的情况下修复一个 bug。如果很难理解和修改一个软件系统，那么它就是复杂的；如果很容易理解和修改，那它就是简单的。</p>
<p>也可以从成本和收益的角度考虑复杂性。在复杂系统中，哪怕是实现一个很小的改进都需要花费很多工作。在简单系统中，可以用更少的工作完成更大的改进。</p>
<p>复杂性是开发者在尝试完成一个特定目标时在特定时间点的经历。并不一定和系统整体的大小或功能相关。人们经常用“复杂（complex）”一词来描述有着复杂（sophisticated）功能的大型系统，但是如果这样的系统开发很容易上手的话，那么，从本书的角度来看，并不复杂（complex）。当然，几乎所有大型和复杂（sophisticated）的软件系统实际上也难以开发，所以它们也符合我这里复杂的定义。但是这并不一定是事实。小型并不复杂（unsophisticated）的系统也有可能非常复杂（complex）。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>复杂性由最常见的活动决定。如果系统中包括一些非常复杂的部分，但是这些基本不会用到，那它们对系统整体的复杂性几乎没影响。用粗略的数学方式来表示：</p>
<p>$C = ∑c_pt_p$</p>
<p>系统整体复杂性（C）由每部分的复杂性 （$c_p$）加权开发者在这部分花费的时间（$t_p$）决定。把复杂性隔离在一个从不会被看到的地方基本就和完全消除了复杂性一样。</p>
<p>相较于编写者，复杂性对阅读者来说更明显。如果你编写了一段对你来说似乎很简单的代码，但是其他人认为它复杂，那么它就是复杂的。当你发现你处于这样的境况中，请其他开发者来看一下为什么他们觉得代码很复杂就很值得一试；在你和他们不同的观点中很有可能学到有趣的东西。作为开发者的工作不仅仅是写出你觉得容易的代码，也要让其他人觉得容易。</p>
<h2 id="22-复杂性的征兆">2.2 复杂性的征兆<a href="#22-复杂性的征兆" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>复杂性通过三种一般的方式表现出来，下面的段落将会描述到。每一种都会使得完成研发任务变得困难。</p>
<figure class="left">
    <img src="/media/software-design/figure-2-1.png"
         alt="figure 2.1"/> <figcaption>
            <p><strong>图2.1：</strong> 网站的每个页面都会展示有颜色的横幅。(a) 中横幅的背景色是在每个页面中显示指定的。(b) 中共享变量保存背景色的值，每个页面都指向这个变量。(c) 中一些页面会展示额外的颜色表示强调，这个颜色是背景色带阴影的较暗的转换；如果背景色变化了，强调色也必须跟着变化。</p>
        </figcaption>
</figure>

<p><strong>放大改变：</strong> 复杂性的第一个征兆是，一个看上去简单的改变需要在许多不同的地方修改代码。比如，考虑有着不同页面的网站，每一个页面都会展示有着背景色的横幅。在很多早期网站中，颜色是由每个页面显示地指定的，如图 2.1(a)。为了改变这个网站的背景色，开发者可能需要手动地修改每个已有页面；对于有着上千张页面的大型网站来说这几乎是不可能的。幸运的是，现代的网站使用了图 2.1(b) 中的方式，横幅颜色在一个集中的地方一次性指定，所有页面都指向这个共享的值。使用这种方式时，整个网站的横幅颜色变化可以由单个修改完成。好的设计的目标之一是，减少每个设计决定会影响到的代码数量，这样修改设计时不需要改动很多代码。</p>
<p><strong>心智负担：</strong> 复杂性第二个征兆是心智负担，心智负担是指开发者为了完成任务需要了解多少东西。更高的心智负担意味着开发者不得不花费更多时间学习必需了解的信息，而且可能会由于他们遗漏了一些重要信息而增加出现 bug 的风险。比如，C 中分配内存的函数返回指向内存的指针，并且假设调用者会释放内存。这增加了使用这个函数的开发者的心智负担；如果开发者没能释放内存，那么就会出现内存泄漏。如果可以重构系统使得开发者无需关心内存释放（分配内存的模块同时负责释放它），就可以降低心智负担。心智负担以多种方式出现，比如有许多方法的 API，全局变量，不一致性，模块间依赖。</p>
<p>系统设计者有时候认为可以用代码行数衡量复杂性。他们认为如果一个实现比另外的短，那么肯定就更简单；如果只需要很少几行就可以做出改变，那这个改变肯定很容易。然而，这个视角忽略了和心智负担有关的成本。我曾经见过只需要几行就可以完成一个应用的框架，但是想要搞懂这几行做了什么事情却及其困难。<strong>有时候需要更多行代码的方式其实更简单，因为它降低了心智负担。</strong></p>
<p><strong>未知的未知：</strong> 复杂性的第三个征兆是，为了完成任务需要修改哪些代码或者开发者需要了解哪些信息并不明显。图 2.1(c) 展示了这个问题。网站使用集中变量来决定横幅背景色，所以看上去很容易修改。然而，一些网页使用了带阴影加深的背景色来表示强调，而这个加深的颜色是在每个页面单独指定的。如果背景色变化了，那强调色也必须相匹配地跟着变化。不幸的是，开发者不太可能意识到这个颜色的存在，所以他们可能修改了集中变量 bannerBg 但是没有更新强调色。即使开发者意识到了这个问题，哪些页面使用了强调色也不明显，所以开发者不得不搜索网站中的所有页面。</p>
<p>复杂性的三种表现方式中，未知的未知是最糟糕的。未知的未知意味着你需要了解一些东西，但是你却无法知道需要了解什么，或者甚至这些东西是否存在。在你修改后，直到出现 bug 之前都无法知道。改变放大很烦人，但是只要知道需要修改哪些代码，一旦完成修改系统还是可以工作。类似的，高的心智负担会增加做出改变的成本，但是如果知道哪些信息需要掌握，改变仍旧很可能是正确的。而未知的未知的情况，你将不知道需要做什么，或者提议的方案是否可以工作。唯一可以确定的方式，是阅读系统的每一行代码，这对任何规模的系统都是不切实际的。即使这样也还不够，因为修改可能依赖于一个从未记录的微小的设计决定。</p>
<p>对于系统来说，好设计的最重要的目标之一是使系统变得浅显易懂。这是高心智负担和未知的未知的对立面。在浅显易懂的系统中，开发者可以快速了解已有代码是如何工作的以及做出修改需要什么。浅显易懂的系统中，开发者可以快速的猜出要做什么，不需要非常认真地思考，而且还可以对猜测很有信心。第十八章讨论了使得代码更浅显易懂的技术。</p>
<h2 id="23-复杂性的原因">2.3 复杂性的原因<a href="#23-复杂性的原因" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>既然你已经知道了复杂性的高层级的征兆，还有为什么复杂性会使得软件开发变困难，下一步就是搞懂什么导致了复杂性，这样我们就可以在设计系统时避免这些问题。复杂性是由两种东西导致的：<em>依赖和模糊</em>。这部分从高层次讨论了这些因素；余下的章节会讨论它们如何与低层次的设计决定相关。</p>
<p>从本书的目的来说，当一段代码无法单独被理解和修改时，就说明存在依赖；这段代码和其他代码以某种方式相关，如果这段代码修改了，也必须考虑和/或修改其他代码。在图 2.1(a) 的网站例子中，背景色创建了所有页面之间的依赖关系。所有页面必须有相同的背景，所以如果一个页面的背景修改了，那么所有其他的页面也必须修改。依赖的另外一个例子出现在网络协议中。一般来说，协议的发送方和接收方代码是独立的，但是它们都必须遵循这个协议；修改发送方的代码几乎总是要求接收方也做出相应修改，反过来也一样。方法的签名创建了这个方法的实现和调用者之间的依赖关系：如果这个方法新增了一个参数，这个方法的所有调用者都必须加以修改来指定这个参数。</p>
<p>依赖是软件中一个基础部分，不能被完全消除。实际上，在软件设计过程中我们会故意引入依赖。你每次新增类的时候，都会创建围绕这个类的 API 的依赖。然而，软件设计的目标之一是减少依赖，并且尽量保持依赖简单和明显。</p>
<p>考虑网站的例子。在每个页面中单独指定背景色的老网站中，所有的网页互相依赖。新网站通过在一个集中的地方指定背景色并提供 API 使得每个页面渲染时可以获取到颜色解决了这个问题。新网站消除了页面之间的依赖，但是创建了围绕获取背景色的 API 的新依赖。幸运的是，新依赖更明显了：每个网页依赖于 bannerBg 是很明显的，开发者可以很容易的找到所有使用这个变量的地方。更进一步的，编译器可以帮助管理 API 依赖：如果共享变量的名字变了，仍然使用原来名字的代码会报编译错误。新的网站用一个更简单更明显的依赖替换了原来不明显、难以管理的依赖。</p>
<p>复杂性的第二个原因是模糊。当重要信息不明显时，模糊就出现了。一个简单的例子是，变量名过于简单，无法携带很多有用信息（比如 时间）。或者，变量的文档可能没有它的单位，所以只能到使用这个变量的地方查看。当依赖的存在不明显时，模糊经常和依赖相关。比如，如果系统中要新增一个错误状态码，可能也需要在存储了每个状态码的文字消息的表中新增一条记录，但是对于看状态定义的程序员来说，消息表的存在可能不够明显。不一致也是模糊的一个重要来源：如果相同的变量名用于两种不同目的，对开发者来说，一个具体的变量服务于哪个目的就不明显了。</p>
<p>在许多情况中，模糊是由于文档不足；第十三章会处理这个主题。然而，模糊也是一个设计问题。如果系统有着干净明显的设计，那么就会需要更少的文档。需要大量文档经常是一个红色警告，说明设计不太对。减少模糊最好的方式是简化系统设计。</p>
<p>总体来说，依赖和模糊要为 2.2 节中描述的复杂性的三种表现方式负责。依赖导致改变放大和高心智负担。模糊创造了未知的未知，同时对心智负担也有贡献。如果我们能找到最小化依赖和模糊的设计技术，那么我们就可以降低系统复杂度。</p>
<h2 id="24-复杂性是增量的">2.4 复杂性是增量的<a href="#24-复杂性是增量的" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>复杂性不是由单个灾难性的错误导致的；它由许多小块积累而成。单个依赖或模糊很难对软件系统的维护造成明显的影响。随着时间而累积的成百上千的小依赖和模糊导致了复杂性。最终，太多的小问题存在以至于系统每个可能的修改都会被这些问题中的几个所影响。</p>
<p>复杂性增量的天性使得它很难控制。很容易说服自己当前改动引入一点复杂性没什么大不了。然而，如果每个开发者每个改动都采用这种方式，复杂度会迅速累积。一旦复杂度累积到一定程度，就很难消除，因为修复单个依赖或模糊不会有什么大的作为。为了减缓复杂性的增速，必须采取“零容忍”的哲学，在第三章中会讨论到。</p>
<h2 id="25-结论">2.5 结论<a href="#25-结论" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>复杂性由依赖和模糊积累而来。随着复杂性增长，会导致改变放大，高心智负担和未知的未知。最终，每个新功能都需要更多代码修改实现。而且，开发者要花费更多时间获取安全变更的足够的信息，在最糟的情况中，他们甚至无法找到所需的所有信息。结果是，复杂性使得修改已有的代码变得困难而且冒险。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>我已当场去世，sophisticated 和 complex 完全不知道怎么区分。。 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

			</div>

<div class="related-posts thin">
	<h2>相关推荐</h2>
	<ul>
	
	<li><a href="/post/philosophy-of-software-design-1/">Philosophy of Software Design 第一章 介绍（一切都与复杂性有关）</a></li>
	
	<li><a href="/post/philosophy-of-software-design-11/">Philosophy of Software Design 第十一章 设计两次</a></li>
	
	<li><a href="/post/philosophy-of-software-design-10/">Philosophy of Software Design 第十章 通过定义使得错误不复存在</a></li>
	
	<li><a href="/post/philosophy-of-software-design-9/">Philosophy of Software Design 第九章 - 合并还是拆分</a></li>
	
	<li><a href="/post/philosophy-of-software-design-8/">Philosophy of Software Design - 第八章 降低复杂性</a></li>
	
	</ul>
</div>

			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://kyon.life/tags/%E9%B9%A6%E9%B9%89%E5%AD%A6%E8%88%8C">鹦鹉学舌</a></span><span class="tag"><a href="https://kyon.life/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">学习笔记</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>约 4636 字</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2020-02-19 12:15</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-git-commit"><circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line></svg><a href="https://github.com/kyon0304/kyon0304.github.io/5d1291eff84f99177f2b55dc7ea896b2ecce2c8d/33755fe4e1897f991c07afdf5b018a390da94d30" target="_blank" rel="noopener">33755fe</a> @ 2020-02-21</p>
			</footer>

			
			<div class="social-share" data-initialized="true" data-wechat-qrcode-title="扫描分享">
    <center>
        <span style="font-size:16px;color:#c05b4d;">分享到：</span>
        <a href="#" class="social-share-icon icon-weibo"></a>
        <a href="#" class="social-share-icon icon-wechat"></a>
        <a href="#" class="social-share-icon icon-twitter"></a>
        <a href="#" class="social-share-icon icon-qq"></a>
        <a href="#" class="social-share-icon icon-qzone"></a>
    </center>
</div>

<script src="/js/social-share.min.js"></script>

		
		</article>
		<aside id="toc" class="show-toc">
			<div class="toc-title">目录</div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#21-定义复杂性">2.1 定义复杂性</a></li>
    <li><a href="#22-复杂性的征兆">2.2 复杂性的征兆</a></li>
    <li><a href="#23-复杂性的原因">2.3 复杂性的原因</a></li>
    <li><a href="#24-复杂性是增量的">2.4 复杂性是增量的</a></li>
    <li><a href="#25-结论">2.5 结论</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="prev-post" href="https://kyon.life/post/philosophy-of-software-design-1/">
				<span class="post-nav-label">旧&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Philosophy of Software Design 第一章 介绍（一切都与复杂性有关）</span>
			</a>
		</div>
		<script src="https://utteranc.es/client.js"
			  repo="kyon0304/kyon0304.github.io"
			  issue-term="pathname"
			  label="Comment"
			  theme="github-light"
			  crossorigin="anonymous"
			  async>
		  </script>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://kyon.life/">kyon</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://kyon.life/sitemap.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://kyon.life/js/bundle.min.cf66415905ed064d02902ca9138e49994c39dd714c91a4a12878e2777abc0fb6.js" integrity="sha256-z2ZBWQXtBk0CkCypE45JmUw53XFMkaShKHjid3q8D7Y=" crossorigin="anonymous"></script>
	
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-131420074-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


	
  
  
  
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-131420074-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script src="/js/social-share.min.js"></script>



</body>

</html>
